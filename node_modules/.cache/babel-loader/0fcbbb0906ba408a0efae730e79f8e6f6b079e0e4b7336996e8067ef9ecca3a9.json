{"ast":null,"code":"function e(e, t, n, r) {\n  let o = [k.run({\n    fn: e => t(e)\n  })];\n  if (r && o.unshift(r), n) {\n    let t = S({\n        node: o\n      }),\n      r = e.graphite.id,\n      u = n.additionalLinks,\n      s = u[r] || [];\n    return u[r] = s, s.push(t), () => {\n      let e = s.indexOf(t);\n      -1 !== e && s.splice(e, 1), g(t);\n    };\n  }\n  {\n    let t = S({\n      node: o,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return () => {\n      g(t);\n    };\n  }\n}\nfunction t(e, t) {\n  return t.displayName = e, t;\n}\nfunction n(t, n) {\n  x.store(t) || R('expect useStore argument to be a store');\n  let r = v.useCallback(r => e(t, r, n), [t, n]),\n    o = v.useCallback(() => U(t, n), [t, n]);\n  return O(r, o, o);\n}\nfunction r(t, n) {\n  let r = x.unit(t),\n    o = {};\n  r ? o = {\n    unit: t\n  } : '@@unitShape' in t ? 'function' == typeof t['@@unitShape'] ? o = t['@@unitShape']() : R('expect @@unitShape to be a function') : o = t;\n  let u = Array.isArray(o),\n    s = v.useRef({\n      stale: 1,\n      justSubscribed: 0,\n      scope: n\n    }),\n    [l, a, i] = v.useMemo(() => {\n      s.current.stale = 1;\n      let e = Array.isArray(o) ? [] : {},\n        t = [],\n        r = [];\n      for (let u in o) {\n        let s = o[u];\n        x.unit(s) || R('expect useUnit argument to be a unit'), x.event(s) || x.effect(s) ? e[u] = n ? j(s, {\n          scope: n\n        }) : s : (e[u] = null, t.push(u), r.push(s));\n      }\n      return [e, t, r];\n    }, [s, n, ...Object.keys(o), ...Object.values(o)]),\n    c = v.useRef({\n      value: l,\n      storeKeys: a\n    }),\n    f = v.useCallback(t => {\n      let r = s.current;\n      r.justSubscribed = 1;\n      let o = () => {\n          r.stale || (r.stale = 1, t());\n        },\n        u = k.compute({\n          priority: 'sampler',\n          batch: 1\n        }),\n        l = i.map(t => e(t, o, n, u));\n      return () => {\n        l.forEach(e => e());\n      };\n    }, [i, n, c, s]),\n    p = v.useCallback(() => {\n      let e,\n        t = c.current,\n        o = s.current,\n        f = 0,\n        p = t.value,\n        d = t.storeKeys,\n        m = n !== o.scope;\n      if (o.stale || o.justSubscribed || m) {\n        f = !o.justSubscribed || m, e = u ? [...l] : {\n          ...l\n        }, d.length !== a.length && (f = 1);\n        for (let t = 0; t < a.length; t++) {\n          let r = U(i[t], n),\n            o = a[t];\n          f || (f = d.includes(o) ? p[o] !== r : 1), e[o] = r;\n        }\n      }\n      return f && (t.value = e), t.storeKeys = a, o.stale = 0, o.justSubscribed = !f, o.scope = n, r ? t.value.unit : t.value;\n    }, [f, i, n, c, s]);\n  return O(f, p, p);\n}\nfunction o(_ref, r) {\n  let [t, n] = _ref;\n  let o,\n    u,\n    s,\n    l,\n    a = K;\n  n ? (o = n, s = t, l = []) : ({\n    fn: o,\n    store: s,\n    keys: l,\n    defaultValue: u,\n    updateFilter: a = K\n  } = t), x.store(s) || R('useStoreMap expects a store'), Array.isArray(l) || R('useStoreMap expects an array as keys'), 'function' != typeof o && R('useStoreMap expects a function');\n  let i = v.useCallback(t => e(s, t, r), [s, r]),\n    c = v.useCallback(() => U(s, r), [s, r]),\n    f = v.useRef(),\n    p = v.useRef(),\n    d = v.useRef(l);\n  return L(i, c, c, e => {\n    if (f.current !== e || !((e, t) => {\n      if (!e || !t || e.length !== t.length) return 0;\n      let n = 1;\n      for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) {\n        n = 0;\n        break;\n      }\n      return n;\n    })(d.current, l)) {\n      let t = o(e, l);\n      void 0 === t && void 0 !== u && (t = u), f.current = e, d.current = l, void 0 !== t && (p.current = t);\n    }\n    return p.current;\n  }, (e, t) => !a(t, e));\n}\nfunction u(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let n = arguments.length > 2 ? arguments[2] : undefined;\n  let {\n      open: o,\n      close: u,\n      set: s\n    } = r({\n      open: e.open,\n      close: e.close,\n      set: e.set\n    }, n),\n    l = v.useMemo(() => ({\n      open: o,\n      close: u,\n      set: s\n    }), [e, o]),\n    a = v.useRef({\n      value: null,\n      count: 0\n    });\n  M(() => (l.open(a.current.value), () => l.close(a.current.value)), [l]), ((e, t) => {\n    if (e === t) return 1;\n    if ('object' == typeof e && null !== e && 'object' == typeof t && null !== t) {\n      let n = Object.keys(e),\n        r = Object.keys(t);\n      if (n.length !== r.length) return 0;\n      for (let r = 0; r < n.length; r++) {\n        let o = n[r];\n        if (e[o] !== t[o]) return 0;\n      }\n      return 1;\n    }\n    return 0;\n  })(a.current.value, t) || (a.current.value = t, a.current.count += 1), M(() => {\n    l.set(a.current.value);\n  }, [a.current.count]);\n}\nfunction s(e) {\n  let t = v.useContext(V);\n  return e && !t && R('No scope found, consider adding <Provider> to app root'), t;\n}\nfunction l(e, t) {\n  return ((e, t) => {\n    if (!t) return e;\n    let n = x.unit(e) || 'object' != typeof e ? {\n      event: e\n    } : e;\n    return v.useMemo(() => {\n      if (x.unit(e)) return j(e, {\n        scope: t\n      });\n      let n = Array.isArray(e) ? [] : {};\n      for (let r in e) n[r] = j(e[r], {\n        scope: t\n      });\n      return n;\n    }, [t, ...Object.keys(n), ...Object.values(n)]);\n  })(e, s(null == t ? void 0 : t.forceScope));\n}\nfunction a(e, t) {\n  return n(e, s(null == t ? void 0 : t.forceScope));\n}\nfunction i(e, t) {\n  return r(e, s(null == t ? void 0 : t.forceScope));\n}\nfunction c(e, t) {\n  return o([e, t], s(null == e ? void 0 : e.forceScope));\n}\nfunction f(e, r, u) {\n  return ((e, r, u) => {\n    let s,\n      l,\n      a,\n      i = [];\n    'object' == typeof r && null !== r ? (r.keys && (i = r.keys), ({\n      fn: s,\n      getKey: l,\n      placeholder: a\n    } = r)) : s = r, x.store(e) || R('expect useList first argument to be a store'), 'function' != typeof s && R(\"expect useList's renderItem to be a function\"), Array.isArray(i) || R(\"expect useList's keys to be an array\");\n    let c = v.useMemo(() => {\n        let n = t(`${e.shortName || 'Unknown'}.Item`, t => {\n          let {\n            index: n,\n            keys: r,\n            keyVal: s,\n            value: l\n          } = t;\n          if (f.current[1]) return f.current[0](l, s);\n          let a = o([{\n            store: e,\n            keys: [n, ...r],\n            fn: (e, t) => e[t[0]]\n          }], u);\n          return f.current[0](a, n);\n        });\n        return v.memo(n);\n      }, [e, u, !!l]),\n      f = v.useRef([s, l]);\n    f.current = [s, l];\n    let p = v.useMemo(() => i, i);\n    if (l) {\n      let t = n(e, u);\n      return 0 === t.length && a ? a : t.map(e => {\n        let t = f.current[1](e);\n        return v.createElement(c, {\n          keyVal: t,\n          key: t,\n          keys: p,\n          value: e\n        });\n      });\n    }\n    {\n      let t = o([{\n        store: e,\n        keys: [e],\n        fn: e => e.length\n      }], u);\n      return 0 === t && a ? a : Array.from({\n        length: t\n      }, (e, t) => v.createElement(c, {\n        index: t,\n        key: t,\n        keys: p\n      }));\n    }\n  })(e, r, s(null == u ? void 0 : u.forceScope));\n}\nfunction p(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let n = arguments.length > 2 ? arguments[2] : undefined;\n  return u(e, t, s(null == n ? void 0 : n.forceScope));\n}\nfunction d(e, n) {\n  function r(e) {\n    let t = v.useRef(e),\n      r = a(o);\n    M(() => (s({\n      props: t.current,\n      state: o.getState()\n    }), () => {\n      l({\n        props: t.current,\n        state: o.getState()\n      });\n    }), []);\n    let u = n(e, r);\n    return t.current = e, u;\n  }\n  let o;\n  x.store(e) ? o = e : 'object' == typeof e && null !== e ? o = C(e) : R('shape should be a store or object with stores');\n  let u = 'Unknown';\n  o && o.shortName && (u = o.shortName);\n  let s = $(),\n    l = $();\n  return r.mounted = s, r.unmounted = l, t(`${u}.View`, r);\n}\nfunction m(e) {\n  return d(e, (_ref2, t) => {\n    let {\n      children: e\n    } = _ref2;\n    return e(t);\n  });\n}\nfunction y(e, t) {\n  let n = t ? e : e[0];\n  var r;\n  (e => {\n    if (!e) throw Error('expect first argument be an object');\n  })(G(r = n) || (e => 'function' == typeof e)(r));\n  let o = n.or,\n    u = n.and;\n  if (u) {\n    let n = t ? u : u[0];\n    if (G(n) && 'and' in n) {\n      let n = y(u, t);\n      e = n[0], o = {\n        ...o,\n        ...n[1]\n      };\n    } else e = u;\n  }\n  return [e, o];\n}\nfunction b(e, t) {\n  let n = t && G(r = t[0]) && (r.and || r.or) ? t : [{\n    and: t\n  }];\n  var r;\n  let o,\n    [[u, s], l] = y(n),\n    a = {},\n    i = {},\n    c = l;\n  var f;\n  return 'string' == typeof u ? (i = {\n    name: u\n  }, G(f = s) && 'sid' in f || (a = s || {})) : (e => G(e) && ('domain' in e || 'defaultState' in e || 'name' in e))(u) && (i = u, a = u.defaultState || {}, o = u.domain), {\n    hook: e,\n    domain: o,\n    defaultState: a,\n    mainConfig: i,\n    maybeConfig: c\n  };\n}\nfunction h() {\n  for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n    e[_key] = arguments[_key];\n  }\n  return (_ref3 => {\n    let {\n      domain: e,\n      defaultState: n,\n      hook: r,\n      mainConfig: o,\n      maybeConfig: u\n    } = _ref3;\n    function l(e) {\n      return r(l, e, s()), null;\n    }\n    let a = W({\n        or: u,\n        and: o\n      }),\n      i = `${e ? `${e.compositeName.fullName}/` : ''}${a.name || 'gate'}`,\n      c = $({\n        name: `${i}.set`,\n        sid: a.sid ? `${a.sid}|set` : void 0\n      }),\n      f = $({\n        name: `${i}.open`,\n        sid: a.sid ? `${a.sid}|open` : void 0\n      }),\n      p = $({\n        name: `${i}.close`,\n        sid: a.sid ? `${a.sid}|close` : void 0\n      }),\n      d = w(Boolean(0), {\n        name: `${i}.status`,\n        serialize: 'ignore'\n      }).on(f, () => Boolean(1)).on(p, () => Boolean(0)),\n      m = w(n, {\n        name: `${i}.state`,\n        sid: a.sid\n      }).on(c, (e, t) => t).on(f, (e, t) => t).reset(p);\n    if (e) {\n      let {\n        hooks: t\n      } = e;\n      A({\n        target: [t.store, t.store, t.event, t.event, t.event],\n        params: [d, m, f, p, c]\n      });\n    }\n    return l.open = f, l.close = p, l.status = d, l.state = m, l.set = c, t(`Gate:${i}`, l);\n  })(b(u, e));\n}\nimport v from 'react';\nimport { step as k, createNode as S, clearNode as g, is as x, scopeBind as j, combine as C, createEvent as $, createStore as w, launch as A } from 'effector/effector.mjs';\nimport E from 'use-sync-external-store/shim/with-selector.js';\nimport N from 'use-sync-external-store/shim/index.js';\nlet R = e => {\n    throw Error(e);\n  },\n  M = 'undefined' != typeof window ? v.useLayoutEffect : v.useEffect;\nconst {\n    useSyncExternalStore: O\n  } = N,\n  {\n    useSyncExternalStoreWithSelector: L\n  } = E,\n  U = (e, t) => t ? t.getState(e) : e.getState(),\n  K = (e, t) => e !== t,\n  V = v.createContext(null);\nlet {\n    Provider: B\n  } = V,\n  I = e => console.error(`${e} is deprecated`),\n  P = (e, n, r) => (I('createContextComponent'), t(`${e.shortName || 'Unknown'}.ContextComponent`, t => {\n    let o = v.useContext(n),\n      u = a(e);\n    return r(t, u, o);\n  })),\n  z = e => n => {\n    let r = e;\n    return 'function' != typeof e && (r = n, n = e), t(`Connect(${r.displayName || r.name || 'Unknown'})`, e => v.createElement(r, {\n      ...e,\n      ...a(n)\n    }));\n  },\n  F = (e, t) => (I('createReactState'), z(t)(e)),\n  G = e => 'object' == typeof e && null !== e,\n  W = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return G(e) && (W(e.or, t), (e => {\n      for (let o in e) r = o, (e => void 0 === e)(n = e[o]) || 'or' === r || 'and' === r || (t[r] = n);\n      var n, r;\n    })(e), W(e.and, t)), t;\n  };\nexport { B as Provider, z as connect, d as createComponent, P as createContextComponent, h as createGate, F as createReactState, m as createStoreConsumer, l as useEvent, p as useGate, f as useList, a as useStore, c as useStoreMap, i as useUnit };","map":{"version":3,"names":["e","t","n","r","o","k","run","fn","unshift","S","node","graphite","id","u","additionalLinks","s","push","indexOf","splice","g","parent","family","owners","displayName","x","store","R","v","useCallback","U","O","unit","Array","isArray","useRef","stale","justSubscribed","scope","l","a","i","useMemo","current","event","effect","j","Object","keys","values","c","value","storeKeys","f","cbCaller","compute","priority","batch","map","forEach","p","d","m","length","includes","_ref","K","defaultValue","updateFilter","L","arguments","undefined","open","close","set","count","M","useContext","V","forceScope","getKey","placeholder","shortName","index","keyVal","memo","createElement","key","from","props","state","getState","C","$","mounted","unmounted","_ref2","children","y","Error","G","or","and","b","name","defaultState","domain","hook","mainConfig","maybeConfig","h","_len","_key","_ref3","W","compositeName","fullName","sid","w","Boolean","serialize","on","reset","hooks","A","target","params","status","step","createNode","clearNode","is","scopeBind","combine","createEvent","createStore","launch","E","N","window","useLayoutEffect","useEffect","useSyncExternalStore","useSyncExternalStoreWithSelector","stateReader","basicUpdateFilter","createContext","Provider","B","I","console","error","P","createContextComponent","z","F","createReactState","flattenConfig","connect","createComponent","createGate","createStoreConsumer","useEvent","useGate","useList","useStore","useStoreMap","useUnit"],"sources":["/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createWatch.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/withDisplayName.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/apiBase.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/scope.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/nossr.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createComponent.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createStoreConsumer.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector/config.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector/is.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector/throw.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createGate.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/throw.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/useIsomorphicLayoutEffect.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/deprecate.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createContextComponent.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/connect.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector-react/createReactState.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector-react/effector/collection.ts"],"sourcesContent":["import {Store, clearNode, step, createNode, Scope, Node, Cmd} from 'effector'\n\nexport function createWatch<T>(\n  store: Store<T>,\n  fn: (value: T) => any,\n  scope?: Scope,\n  batchStep?: Cmd,\n) {\n  const seq: Cmd[] = [step.run({fn: value => fn(value)})]\n  if (batchStep) seq.unshift(batchStep)\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (store as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return () => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    }\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [store],\n      family: {owners: store},\n    })\n    return () => {\n      clearNode(node)\n    }\n  }\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import {Store, is, step, scopeBind, Scope, Unit, Event} from 'effector'\nimport React from 'react'\nimport {useSyncExternalStore} from 'use-sync-external-store/shim'\nimport {useSyncExternalStoreWithSelector} from 'use-sync-external-store/shim/with-selector'\nimport {throwError} from './throw'\nimport {createWatch} from './createWatch'\nimport {withDisplayName} from './withDisplayName'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {Gate} from './index.h'\n\nconst stateReader = <T>(store: Store<T>, scope?: Scope) =>\n  scope ? scope.getState(store) : store.getState()\nconst basicUpdateFilter = <T>(upd: T, oldValue: T) => upd !== oldValue\nconst keysEqual = (a?: readonly any[], b?: readonly any[]) => {\n  if (!a || !b || a.length !== b.length) return false\n\n  let isEqual = true\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      isEqual = false\n      break\n    }\n  }\n\n  return isEqual\n}\n\nexport function useStoreBase<State>(store: Store<State>, scope?: Scope) {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n  const currentValue = useSyncExternalStore(subscribe, read, read)\n\n  return currentValue\n}\n\nexport function useUnitBase<Shape extends {[key: string]: Unit<any>}>(\n  shape: Shape | {'@@unitShape': () => Shape},\n  scope?: Scope,\n) {\n  const isSingleUnit = is.unit(shape)\n  let normShape: {[key: string]: Unit<any>} = {}\n  if (isSingleUnit) {\n    normShape = {unit: shape}\n  } else if ('@@unitShape' in shape) {\n    if (typeof shape['@@unitShape'] === 'function') {\n      normShape = shape['@@unitShape']()\n    } else {\n      throwError('expect @@unitShape to be a function')\n    }\n  } else {\n    normShape = shape\n  }\n  const isList = Array.isArray(normShape)\n  const flagsRef = React.useRef({\n    stale: true,\n    justSubscribed: false,\n    scope,\n  })\n  const [eventsShape, storeKeys, storeValues] = React.useMemo(() => {\n    flagsRef.current.stale = true\n    const shape = Array.isArray(normShape) ? [] : ({} as any)\n    const storeKeys: string[] = []\n    const storeValues: Array<Store<any>> = []\n    for (const key in normShape) {\n      const unit = normShape[key]\n      if (!is.unit(unit)) throwError('expect useUnit argument to be a unit')\n      if (is.event(unit) || is.effect(unit)) {\n        shape[key] = scope ? scopeBind(unit as Event<any>, {scope}) : unit\n      } else {\n        shape[key] = null\n        storeKeys.push(key)\n        storeValues.push(unit as Store<any>)\n      }\n    }\n    return [shape, storeKeys, storeValues]\n  }, [flagsRef, scope, ...Object.keys(normShape), ...Object.values(normShape)])\n  const stateRef = React.useRef({value: eventsShape, storeKeys})\n  const subscribe = React.useCallback(\n    (cb: () => void) => {\n      const flags = flagsRef.current\n      flags.justSubscribed = true\n      const cbCaller = () => {\n        if (!flags.stale) {\n          flags.stale = true\n          cb()\n        }\n      }\n      const batchStep = step.compute({priority: 'sampler', batch: true})\n      const subs = storeValues.map(store =>\n        createWatch(store, cbCaller, scope, batchStep),\n      )\n      return () => {\n        subs.forEach(fn => fn())\n      }\n    },\n    [storeValues, scope, stateRef, flagsRef],\n  )\n  const read = React.useCallback(() => {\n    const state = stateRef.current\n    const flags = flagsRef.current\n    let resultValue\n    let changed = false\n    const oldVal = state.value\n    const oldKeys = state.storeKeys\n    const scopeChanged = scope !== flags.scope\n    if (flags.stale || flags.justSubscribed || scopeChanged) {\n      changed = !flags.justSubscribed || scopeChanged\n      resultValue = isList ? [...eventsShape] : {...eventsShape}\n      if (oldKeys.length !== storeKeys.length) {\n        changed = true\n      }\n      for (let i = 0; i < storeKeys.length; i++) {\n        const updatedValue = stateReader(storeValues[i], scope)\n        const key = storeKeys[i]\n        if (!changed) {\n          if (!oldKeys.includes(key)) {\n            changed = true\n          } else {\n            changed = oldVal[key] !== updatedValue\n          }\n        }\n        resultValue[key] = updatedValue\n      }\n    }\n    if (changed) {\n      state.value = resultValue\n    }\n    state.storeKeys = storeKeys\n    flags.stale = false\n    flags.justSubscribed = !changed\n    flags.scope = scope\n    return isSingleUnit ? state.value.unit : state.value\n  }, [subscribe, storeValues, scope, stateRef, flagsRef])\n  return useSyncExternalStore(subscribe, read, read)\n}\n\nexport function useStoreMapBase<State, Result, Keys extends ReadonlyArray<any>>(\n  [configOrStore, separateFn]: [\n    configOrStore:\n      | {\n          store: Store<State>\n          keys: Keys\n          fn(state: State, keys: Keys): Result\n          updateFilter?: (update: Result, current: Result) => boolean\n          defaultValue?: Result\n        }\n      | Store<State>,\n    separateFn?: (state: State, keys: Keys) => Result,\n  ],\n  scope?: Scope,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean =\n    basicUpdateFilter\n  let defaultValue: Result | undefined\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = [] as unknown as Keys\n  } else {\n    ;({\n      fn,\n      store,\n      keys,\n      defaultValue,\n      updateFilter = basicUpdateFilter,\n    } = configOrStore as any)\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n\n  const subscribe = React.useCallback(\n    (cb: () => void) => createWatch(store, cb, scope),\n    [store, scope],\n  )\n  const read = React.useCallback(\n    () => stateReader(store, scope),\n    [store, scope],\n  )\n\n  const stateRef = React.useRef<State>()\n  const valueRef = React.useRef<Result>()\n  const keysRef = React.useRef(keys)\n\n  const value = useSyncExternalStoreWithSelector(\n    subscribe,\n    read,\n    read,\n    state => {\n      if (stateRef.current !== state || !keysEqual(keysRef.current, keys)) {\n        let result = fn(state, keys)\n        if (result === undefined && defaultValue !== undefined) {\n          result = defaultValue\n        }\n        stateRef.current = state\n        keysRef.current = keys\n\n        /**\n         * skip update, if undefined\n         * just like original store or previous implementation\n         */\n        if (result !== undefined) {\n          valueRef.current = result\n        }\n      }\n\n      return valueRef.current as Result\n    },\n    (current, update) => !updateFilter(update, current),\n  )\n\n  return value\n}\nexport function useListBase<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  scope?: Scope,\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: ((item: T) => string) | void\n  let placeholder: React.ReactNode | void\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    ;({fn, getKey, placeholder} = renderItem)\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMapBase(\n          [\n            {\n              store: list,\n              keys: [index, ...keys],\n              fn: (list, keys) => list[keys[0]],\n            },\n          ],\n          scope,\n        )\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, scope, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    const listItems = useStoreBase(list, scope)\n    if (listItems.length === 0 && placeholder) return placeholder\n    return listItems.map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMapBase(\n      [\n        {\n          store: list,\n          keys: [list],\n          fn: list => list.length,\n        },\n      ],\n      scope,\n    )\n    if (length === 0 && placeholder) return placeholder\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n\nexport function useEventBase(eventObject: any, scope?: Scope) {\n  if (!scope) {\n    return eventObject\n  }\n  const isShape = !is.unit(eventObject) && typeof eventObject === 'object'\n  const events = isShape ? eventObject : {event: eventObject}\n\n  return React.useMemo(() => {\n    if (is.unit(eventObject)) {\n      //@ts-expect-error\n      return scopeBind(eventObject, {scope})\n    }\n    const shape = Array.isArray(eventObject) ? [] : ({} as any)\n    for (const key in eventObject) {\n      shape[key] = scopeBind(eventObject[key], {scope})\n    }\n    return shape\n  }, [scope, ...Object.keys(events), ...Object.values(events)])\n}\n\nexport function useGateBase<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  scope?: Scope,\n) {\n  const {open, close, set} = useUnitBase(\n    {\n      open: GateComponent.open,\n      close: GateComponent.close,\n      set: GateComponent.set,\n    },\n    scope,\n  )\n  const ForkedGate = React.useMemo(\n    () =>\n      ({\n        open,\n        close,\n        set,\n      } as Gate<Props>),\n    [GateComponent, open],\n  )\n\n  const propsRef = React.useRef<{value: any; count: number}>({\n    value: null,\n    count: 0,\n  })\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.open(propsRef.current.value)\n    return () => ForkedGate.close(propsRef.current.value) as any\n  }, [ForkedGate])\n  if (!shallowCompare(propsRef.current.value, props)) {\n    propsRef.current.value = props\n    propsRef.current.count += 1\n  }\n  useIsomorphicLayoutEffect(() => {\n    ForkedGate.set(propsRef.current.value)\n  }, [propsRef.current.count])\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\n","import React from 'react'\nimport {Scope} from 'effector'\nimport {throwError} from './throw'\n\nconst ScopeContext = React.createContext(null as Scope | null)\nexport const {Provider} = ScopeContext\nexport function getScope(forceScope?: boolean) {\n  const scope = React.useContext(ScopeContext)\n  if (forceScope && !scope)\n    throwError('No scope found, consider adding <Provider> to app root')\n  return scope as Scope\n}\n","import {Event, Store} from 'effector'\nimport {\n  useStoreBase,\n  useStoreMapBase,\n  useListBase,\n  useUnitBase,\n  useEventBase,\n  useGateBase,\n} from './apiBase'\nimport {getScope} from './scope'\nimport type {Gate} from './index.h'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(\n  event: Event<T>,\n  opts?: {forceScope?: boolean},\n): (payload: T) => T {\n  const scope = getScope(opts?.forceScope)\n\n  return useEventBase(event, scope)\n}\n\nexport function useStore<State>(\n  store: Store<State>,\n  opts?: {forceScope?: boolean},\n): State {\n  return useStoreBase(store, getScope(opts?.forceScope))\n}\n\nexport function useUnit(shape, opts?: {forceScope?: boolean}) {\n  return useUnitBase(shape, getScope(opts?.forceScope))\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n        defaultValue?: Result\n        forceScope?: boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  return useStoreMapBase(\n    [configOrStore, separateFn],\n    getScope(configOrStore?.forceScope),\n  )\n}\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n        placeholder?: React.ReactNode\n      }\n    | ((item: T, index: number) => React.ReactNode),\n  opts?: {forceScope?: boolean},\n): React.ReactNode {\n  return useListBase(list, renderItem, getScope(opts?.forceScope))\n}\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n  opts?: {forceScope?: boolean},\n) {\n  return useGateBase(GateComponent, props, getScope(opts?.forceScope))\n}\n","import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './nossr'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n","import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {createStore, launch, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {useGateBase} from './apiBase'\nimport {getScope} from './scope'\nimport {flattenConfig, processArgsToConfig} from '../effector/config'\nimport {isObject} from '../effector/is'\n\nexport function createGateImplementation<State>({\n  domain,\n  defaultState,\n  hook: useGateHook,\n  mainConfig,\n  maybeConfig,\n}: {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n}): Gate<State> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: mainConfig,\n  }) as {sid: string | undefined; name: string | undefined}\n  const name = config.name || 'gate'\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>({\n    name: `${fullName}.set`,\n    sid: config.sid ? `${config.sid}|set` : undefined,\n  })\n  const open = createEvent<State>({\n    name: `${fullName}.open`,\n    sid: config.sid ? `${config.sid}|open` : undefined,\n  })\n  const close = createEvent<State>({\n    name: `${fullName}.close`,\n    sid: config.sid ? `${config.sid}|close` : undefined,\n  })\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n    serialize: 'ignore',\n    // doesn't need to have sid, because it is internal store, should not be serialized\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n    sid: config.sid,\n  })\n    .on(set, (_, state) => state)\n    .on(open, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props, getScope())\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\n\nconst isPluginConfig = (config: Record<string, any> | string) =>\n  isObject(config) && 'sid' in config\n\nconst isGateConfig = (config: Record<string, any> | string) =>\n  isObject(config) &&\n  ('domain' in config || 'defaultState' in config || 'name' in config)\n\nconst isStructuredConfig = (arg: unknown) =>\n  isObject(arg) && (arg.and || arg.or)\n\nexport function processCreateGateConfig<State>(\n  hook: typeof useGateBase,\n  args: unknown[],\n): {\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGateBase\n  mainConfig?: Record<string, any>\n  maybeConfig?: Record<string, any> & {sid?: string}\n} {\n  const universalConfig =\n    args && isStructuredConfig(args[0]) ? args : [{and: args}]\n  const [[nameOrConfig, defaultStateOrConfig], metadata] =\n    processArgsToConfig(universalConfig)\n\n  let domain\n  let defaultState = {}\n  let mainConfig = {}\n  let maybeConfig = metadata\n\n  if (typeof nameOrConfig === 'string') {\n    mainConfig = {name: nameOrConfig}\n    if (isPluginConfig(defaultStateOrConfig)) {\n      // maybeConfig = defaultStateOrConfig\n    } else {\n      defaultState = defaultStateOrConfig || {}\n    }\n  } else if (isGateConfig(nameOrConfig)) {\n    mainConfig = nameOrConfig\n    defaultState = nameOrConfig.defaultState || {}\n    domain = nameOrConfig.domain\n  }\n  return {\n    hook,\n    domain,\n    defaultState,\n    mainConfig,\n    maybeConfig,\n  }\n}\n\nexport function createGate<Props>(...args: unknown[]): Gate<Props> {\n  return createGateImplementation<Props>(\n    processCreateGateConfig(useGateBase, args),\n  )\n}\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const deprecate = (method: string) =>\n  console.error(`${method} is deprecated`)\n","import React from 'react'\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\nimport {deprecate} from './deprecate'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> => {\n  deprecate('createContextComponent')\n  return withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n}\n","import React from 'react'\n\nimport type {Store} from 'effector'\nimport {useStore} from './nossr'\nimport {withDisplayName} from './withDisplayName'\n\nexport const connect =\n  <State>(Component: React.ComponentType<any>) =>\n  (store: Store<State>) => {\n    let View: any = Component\n    if (typeof Component !== 'function') {\n      View = store\n      store = Component as any\n    }\n    const wrappedComponentName = View.displayName || View.name || 'Unknown'\n    return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n      React.createElement(View, {...props, ...useStore(store)}),\n    )\n  }\n","import type {ComponentType} from 'react'\nimport type {Store} from 'effector'\n\nimport {connect} from './connect'\nimport {deprecate} from './deprecate'\n\nexport const createReactState = (\n  store: Store<any>,\n  View: ComponentType<any>,\n) => {\n  deprecate('createReactState')\n  return connect(View)(store)\n}\n","export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}