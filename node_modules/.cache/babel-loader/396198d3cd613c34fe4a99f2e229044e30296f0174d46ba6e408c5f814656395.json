{"ast":null,"code":"function e(e, t) {\n  for (let r in e) t(e[r], r);\n}\nfunction t(e, t) {\n  e.forEach(t);\n}\nfunction r(e, t) {\n  if (!e) throw Error(t);\n}\nfunction n(e, t) {\n  let r = V(e).meta || {};\n  he = {\n    id: V(e).id,\n    parent: he,\n    value: e,\n    template: r.template || be(),\n    sidRoot: r.sidRoot || he && he.sidRoot,\n    meta: r\n  };\n  try {\n    return t();\n  } finally {\n    ye('region'), he = U(he);\n  }\n}\nfunction a() {\n  let {\n    node: e = [],\n    from: r,\n    source: n,\n    parent: a = r || n,\n    to: i,\n    target: o,\n    child: l = i || o,\n    scope: s = {},\n    meta: f = {},\n    family: u = {\n      type: 'regular'\n    },\n    regional: d\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let c = Se(a),\n    p = Se(u.links),\n    m = Se(u.owners),\n    g = [];\n  t(e, e => e && le(g, e));\n  let h = {\n    id: pe(),\n    seq: g,\n    next: Se(l),\n    meta: f,\n    scope: s,\n    family: {\n      type: u.type || \"crosslink\",\n      links: p,\n      owners: m\n    }\n  };\n  return t(p, e => le(L(e), h)), t(m, e => le(T(e), h)), t(c, e => le(e.next, h)), d && he && we(W(he), [h]), h;\n}\nfunction i(e, r, n) {\n  let a,\n    i = at,\n    o = null,\n    l = et;\n  if (e.target && (r = e.params, n = e.defer, a = e.meta, i = 'page' in e ? e.page : i, e.stack && (o = e.stack), l = G(e) || l, e = e.target), l && et && l !== et && (et = null), Array.isArray(e)) for (let t = 0; t < e.length; t++) Qe('pure', i, V(e[t]), o, r[t], l, a);else Qe('pure', i, V(e), o, r, l, a);\n  if (n && !tt) return;\n  let s,\n    f,\n    u,\n    d,\n    c,\n    p,\n    m = {\n      isRoot: tt,\n      currentPage: at,\n      scope: et,\n      isWatch: rt,\n      isPure: nt\n    };\n  tt = 0;\n  e: for (; d = Ke();) {\n    let {\n      idx: e,\n      stack: r,\n      type: n\n    } = d;\n    u = r.node, at = c = r.page, et = G(r), c ? p = c.reg : et && (p = et.reg);\n    let a = !!c,\n      i = !!et,\n      o = {\n        fail: 0,\n        scope: u.scope\n      };\n    s = f = 0;\n    for (let t = e; t < u.seq.length && !s; t++) {\n      let l = u.seq[t];\n      if (l.order) {\n        let {\n            priority: a,\n            barrierID: i\n          } = l.order,\n          o = i ? c ? `${c.fullID}_${i}` : i : 0;\n        if (t !== e || n !== a) {\n          i ? Ze.has(o) || (Ze.add(o), Xe(t, r, a, i)) : Xe(t, r, a);\n          continue e;\n        }\n        i && Ze.delete(o);\n      }\n      switch (l.type) {\n        case 'mov':\n          {\n            let e,\n              t = l.data;\n            switch (t.from) {\n              case _:\n                e = W(r);\n                break;\n              case \"a\":\n              case 'b':\n                e = r[t.from];\n                break;\n              case \"value\":\n                e = t.store;\n                break;\n              case \"store\":\n                if (p && !p[t.store.id]) if (a) {\n                  let e = st(c, t.store.id);\n                  r.page = c = e, e ? p = e.reg : i ? (pt(et, t.store, 0, 1, t.softRead), p = et.reg) : p = void 0;\n                } else i && pt(et, t.store, 0, 1, t.softRead);\n                e = Be(p && p[t.store.id] || t.store);\n            }\n            switch (t.to) {\n              case _:\n                r.value = e;\n                break;\n              case \"a\":\n              case 'b':\n                r[t.to] = e;\n                break;\n              case \"store\":\n                ut(c, et, u, t.target).current = e;\n            }\n            break;\n          }\n        case 'compute':\n          let e = l.data;\n          if (e.fn) {\n            rt = 'watch' === J(u, 'op'), nt = e.pure;\n            let t = e.safe ? (0, e.fn)(W(r), o.scope, r) : mt(o, e.fn, r);\n            e.filter ? f = !t : r.value = t, rt = m.isWatch, nt = m.isPure;\n          }\n      }\n      s = o.fail || f;\n    }\n    if (ft && ft(r, o), !s) {\n      let e = W(r),\n        n = G(r);\n      if (t(u.next, t => {\n        Qe('child', c, t, r, e, n);\n      }), n) {\n        J(u, 'needFxCounter') && Qe('child', c, n.fxCount, r, e, n), J(u, 'storeChange') && Qe('child', c, n.storeChange, r, e, n), J(u, 'warnSerialize') && Qe('child', c, n.warnSerializeNode, r, e, n);\n        let a = n.additionalLinks[u.id];\n        a && t(a, t => {\n          Qe('child', c, t, r, e, n);\n        });\n      }\n    }\n  }\n  tt = m.isRoot, at = m.currentPage, et = G(m);\n}\nfunction o(t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  let n = r + '(',\n    a = '',\n    i = 0;\n  return e(t, e => {\n    i < 25 && (null != e && (n += a, n += X(e) ? Q(e).fullName : e.toString()), i += 1, a = ', ');\n  }), n + ')';\n}\nfunction l(e, t) {\n  e.shortName = t, Object.assign(Q(e), s(t, U(e)));\n}\nfunction s(e, t) {\n  let r,\n    n,\n    a = e;\n  if (t) {\n    let a = Q(t);\n    0 === e.length ? (r = a.path, n = a.fullName) : (r = a.path.concat([e]), n = 0 === a.fullName.length ? e : a.fullName + '/' + e);\n  } else r = 0 === e.length ? [] : [e], n = e;\n  return {\n    shortName: a,\n    fullName: n,\n    path: r\n  };\n}\nfunction f(e, t) {\n  let r = t ? e : e[0];\n  je(r);\n  let n = r.or,\n    a = r.and;\n  if (a) {\n    let r = t ? a : a[0];\n    if (xe(r) && 'and' in r) {\n      let r = f(a, t);\n      e = r[0], n = {\n        ...n,\n        ...r[1]\n      };\n    } else e = a;\n  }\n  return [e, n];\n}\nfunction u(e) {\n  let r = be();\n  if (r) {\n    let n = r.handlers[e];\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n    if (n) return n(r, ...t);\n  }\n}\nfunction d(e, t) {\n  let r = gt({\n      or: t,\n      and: 'string' == typeof e ? {\n        name: e\n      } : e\n    }),\n    n = function (e) {\n      for (var _len2 = arguments.length, t = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        t[_key2 - 1] = arguments[_key2];\n      }\n      return se(!J(n, 'derived'), 'call of derived event', 'createEvent'), se(!nt, 'unit call from pure function', 'operators like sample'), at ? ((e, t, r, n) => {\n        let a = at,\n          i = null;\n        if (t) for (i = at; i && i.template !== t;) i = U(i);\n        lt(i);\n        let o = e.create(r, n);\n        return lt(a), o;\n      })(n, o, e, t) : n.create(e, t);\n    },\n    o = be(),\n    l = Object.assign(n, {\n      graphite: a({\n        meta: $t(r.actualOp || \"event\", n, r),\n        regional: 1\n      }),\n      create: e => (i({\n        target: n,\n        params: e,\n        scope: et\n      }), e),\n      watch: e => xt(n, e),\n      map: e => jt(n, P, e, [Ve()]),\n      filter: e => jt(n, \"filter\", e.fn ? e : e.fn, [Ve(qe, 1)]),\n      filterMap: e => jt(n, 'filterMap', e, [Ve(), Pe(e => !$e(e), 1)]),\n      prepend(e) {\n        let t = d('* \\u2192 ' + n.shortName, {\n          parent: U(n)\n        });\n        return u('eventPrepend', V(t)), wt(t, n, [Ve()], 'prepend', e), zt(n, t), t;\n      }\n    });\n  return null != r && r.domain && r.domain.hooks.event(l), ye(l.graphite), l;\n}\nfunction c(e, n, a, i) {\n  return Me(a, n, 'first argument'), r(ze(i), 'second argument should be a function'), se(!J(e, 'derived'), `${n} in derived store`, `${n} in store created via createStore`), t(Array.isArray(a) ? a : [a], t => {\n    e.off(t), H(e).set(t, kt(Ct(t, e, 'on', Oe, i)));\n  }), e;\n}\nfunction p(e, n) {\n  let o = gt(n),\n    l = Te(e),\n    s = d({\n      named: 'updates',\n      derived: 1\n    });\n  u('storeBase', l);\n  let f = l.id,\n    m = {\n      subscribers: new Map(),\n      updates: s,\n      defaultState: e,\n      stateRef: l,\n      getState() {\n        let e,\n          t = l;\n        if (at) {\n          let t = at;\n          for (; t && !t.reg[f];) t = U(t);\n          t && (e = t);\n        }\n        return !e && et && (pt(et, l, 1), e = et), e && (t = e.reg[f]), Be(t);\n      },\n      setState: e => i({\n        target: m,\n        params: e,\n        defer: 1,\n        scope: et\n      }),\n      reset: function () {\n        for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          e[_key3] = arguments[_key3];\n        }\n        return t(e, e => c(m, '.reset', e, () => m.defaultState)), m;\n      },\n      on: (e, t) => c(m, '.on', e, t),\n      off(e) {\n        let t = H(m).get(e);\n        return t && (t(), H(m).delete(e)), m;\n      },\n      map(e, t) {\n        let r, n;\n        xe(e) && (r = e, e = e.fn), se($e(t), 'second argument of store.map', 'updateFilter');\n        let a = m.getState();\n        be() ? n = null : $e(a) || (n = e(a, t));\n        let i = p(n, {\n            name: `${m.shortName} \\u2192 *`,\n            derived: 1,\n            and: r\n          }),\n          o = Ct(m, i, P, Ie, e);\n        return We(B(i), {\n          type: P,\n          fn: e,\n          from: l\n        }), B(i).noInit = 1, u('storeMap', l, o), i;\n      },\n      watch(e, t) {\n        if (!t || !X(e)) {\n          let t = xt(m, e);\n          return u('storeWatch', l, e) || e(m.getState()), t;\n        }\n        return r(ze(t), 'second argument should be a function'), e.watch(e => t(m.getState(), e));\n      }\n    },\n    g = $t(\"store\", m, o),\n    h = m.defaultConfig.updateFilter;\n  m.graphite = a({\n    scope: {\n      state: l,\n      fn: h\n    },\n    node: [Pe((e, t, r) => (r.scope && !r.scope.reg[l.id] && (r.b = 1), e)), _e(l), Pe((e, t, _ref) => {\n      let {\n        a: r,\n        b: n\n      } = _ref;\n      return !$e(e) && (e !== r || n);\n    }, 1), h && Ve(Ie, 1), De({\n      from: _,\n      target: l\n    })],\n    child: s,\n    meta: {\n      ...g,\n      defaultState: e\n    },\n    regional: 1\n  });\n  let y = J(m, 'serialize'),\n    b = J(m, 'derived'),\n    v = 'ignore' === y,\n    k = !y || v ? 0 : y,\n    w = J(m, 'sid');\n  return w && (K(m, 'storeChange', 1), l.sid = w, k && (l.meta = {\n    ...(null == l ? void 0 : l.meta),\n    serialize: k\n  })), w || v || b || K(m, 'warnSerialize', 1), r(b || !$e(e), \"current state can't be undefined, use null instead\"), we(m, [s]), null != o && o.domain && o.domain.hooks.store(m), b || (m.reinit = d({\n    named: 'reinit'\n  }), m.reset(m.reinit)), ye(m.graphite), m;\n}\nfunction m() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n  let t, n, a;\n  [e, a] = f(e);\n  let i,\n    o,\n    l,\n    s = e[e.length - 1];\n  if (ze(s) ? (n = e.slice(0, -1), t = s) : n = e, 1 === n.length) {\n    let e = n[0];\n    Z(e) || (i = e, o = 1);\n  }\n  if (!o && (i = n, t)) {\n    l = 1;\n    let e = t;\n    t = t => e(...t);\n  }\n  return r(xe(i), 'shape should be an object'), Mt(Array.isArray(i), !l, i, a, t);\n}\nfunction g() {\n  return se(0, 'createStoreObject', 'combine'), m(...arguments);\n}\nfunction h() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\nfunction y(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let n = gt(ze(e) ? {\n      handler: e\n    } : e, t),\n    o = d(ze(e) ? {\n      handler: e\n    } : e, {\n      ...t,\n      actualOp: \"effect\"\n    }),\n    l = V(o);\n  K(l, 'op', o.kind = \"effect\"), o.use = e => (r(ze(e), '.use argument should be a function'), g.scope.handler = e, o), o.use.getCurrent = () => g.scope.handler;\n  let s = o.finally = d({\n      named: 'finally',\n      derived: 1\n    }),\n    f = o.done = s.filterMap({\n      named: 'done',\n      fn(_ref2) {\n        let {\n          status: e,\n          params: t,\n          result: r\n        } = _ref2;\n        if ('done' === e) return {\n          params: t,\n          result: r\n        };\n      }\n    }),\n    u = o.fail = s.filterMap({\n      named: 'fail',\n      fn(_ref3) {\n        let {\n          status: e,\n          params: t,\n          error: r\n        } = _ref3;\n        if ('fail' === e) return {\n          params: t,\n          error: r\n        };\n      }\n    }),\n    c = o.doneData = f.map({\n      named: 'doneData',\n      fn: _ref4 => {\n        let {\n          result: e\n        } = _ref4;\n        return e;\n      }\n    }),\n    m = o.failData = u.map({\n      named: 'failData',\n      fn: _ref5 => {\n        let {\n          error: e\n        } = _ref5;\n        return e;\n      }\n    }),\n    g = a({\n      scope: {\n        handlerId: J(l, 'sid'),\n        handler: o.defaultConfig.handler || (() => r(0, `no handler used in ${o.getType()}`))\n      },\n      node: [Pe((e, t, r) => {\n        let n = t,\n          a = n.handler;\n        if (G(r)) {\n          let e = G(r).handlers[n.handlerId];\n          e && (a = e);\n        }\n        return e.handler = a, e;\n      }, 0, 1), Pe((_ref6, a, i) => {\n        let {\n          params: e,\n          req: t,\n          handler: r,\n          args: n = [e]\n        } = _ref6;\n        let o = It(i),\n          l = Ot(e, t, 1, s, i, o),\n          f = Ot(e, t, 0, s, i, o),\n          [u, d] = At(r, f, n);\n        u && (xe(d) && ze(d.then) ? d.then(l, f) : l(d));\n      }, 0, 1)],\n      meta: {\n        op: 'fx',\n        fx: 'runner'\n      }\n    });\n  l.scope.runner = g, le(l.seq, Pe((e, _ref7, r) => {\n    let {\n      runner: t\n    } = _ref7;\n    let n = U(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n        rj(e) {}\n      }\n    } : e;\n    return r.meta || (r.meta = {\n      fxID: me()\n    }), i({\n      target: t,\n      params: n,\n      defer: 1,\n      scope: G(r),\n      meta: r.meta\n    }), n.params;\n  }, 0, 1)), o.create = e => {\n    let t = h(),\n      r = {\n        params: e,\n        req: t\n      };\n    if (et && !rt) {\n      let e = et;\n      t.req.finally(() => {\n        ot(e);\n      }).catch(() => {});\n    }\n    return i({\n      target: o,\n      params: r,\n      scope: et\n    }), t.req;\n  };\n  let y = o.inFlight = p(0, {\n    serialize: 'ignore'\n  }).on(o, e => e + 1).on(s, e => e - 1).map({\n    fn: e => e,\n    named: 'inFlight'\n  });\n  K(s, 'needFxCounter', 'dec'), K(o, 'needFxCounter', 1);\n  let b = o.pending = y.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return we(o, [s, f, u, c, m, b, y]), null != n && n.domain && n.domain.hooks.effect(o), o;\n}\nfunction b(e) {\n  let t;\n  [e, t] = f(e, 1);\n  let {\n      source: r,\n      effect: n,\n      mapParams: a\n    } = e,\n    o = y(e, t);\n  K(o, 'attached', 1);\n  let l,\n    {\n      runner: u\n    } = V(o).scope,\n    d = Pe((e, t, n) => {\n      let l,\n        {\n          params: s,\n          req: f,\n          handler: u\n        } = e,\n        d = o.finally,\n        c = It(n),\n        p = Ot(s, f, 0, d, n, c),\n        m = n.a,\n        g = te(u),\n        h = 1;\n      if (a ? [h, l] = At(a, p, [s, m]) : l = r && g ? m : s, h) {\n        if (!g) return e.args = [m, l], 1;\n        i({\n          target: u,\n          params: {\n            params: l,\n            req: {\n              rs: Ot(s, f, 1, d, n, c),\n              rj: p\n            }\n          },\n          page: n.page,\n          defer: 1,\n          meta: n.meta\n        });\n      }\n    }, 1, 1);\n  if (r) {\n    let e;\n    Z(r) ? (e = r, we(e, [o])) : (e = m(r), we(o, [e])), l = [_e(B(e)), d];\n  } else l = [d];\n  u.seq.splice(1, 0, ...l), o.use(n);\n  let c = U(n);\n  return c && (Object.assign(Q(o), s(o.shortName, c)), o.defaultConfig.parent = c), zt(n, o, \"effect\"), o;\n}\nfunction v() {\n  for (var _len5 = arguments.length, t = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    t[_key5] = arguments[_key5];\n  }\n  let [[r, n], a] = f(t),\n    i = {};\n  return e(n, (e, t) => {\n    let n = i[t] = d(t, {\n      parent: U(r),\n      config: a\n    });\n    r.on(n, e), zt(r, n);\n  }), i;\n}\nfunction k(r, n) {\n  let o = gt({\n      or: n,\n      and: 'string' == typeof r ? {\n        name: r\n      } : r\n    }),\n    l = a({\n      family: {\n        type: \"domain\"\n      },\n      regional: 1,\n      parent: (null == o ? void 0 : o.domain) || (null == o ? void 0 : o.parent)\n    }),\n    s = {\n      history: {},\n      graphite: l,\n      hooks: {}\n    };\n  l.meta = $t(\"domain\", s, {\n    parent: (null == o ? void 0 : o.domain) || (null == o ? void 0 : o.parent),\n    or: o\n  }), e({\n    Event: d,\n    Effect: y,\n    Store: p,\n    Domain: k\n  }, (e, r) => {\n    let n = r.toLowerCase(),\n      a = d({\n        named: `on${r}`\n      });\n    s.hooks[n] = a;\n    let o = new Set();\n    s.history[`${n}s`] = o, a.create = e => (i(a, e), e), le(V(a).seq, Pe((e, t, r) => (r.scope = null, e))), a.watch(e => {\n      we(s, [e]), o.add(e), e.ownerSet || (e.ownerSet = o), U(e) || (e.parent = s);\n    }), we(s, [a]), s[`onCreate${r}`] = e => (t(o, e), a.watch(e)), s[`create${r}`] = s[n] = (t, r) => {\n      let n = gt({\n        and: r,\n        or: t\n      });\n      return null != n && n.domain ? e(t, r) : a(e(t, {\n        parent: s,\n        or: n\n      }));\n    };\n  });\n  let f = U(s);\n  return f && e(s.hooks, (e, t) => wt(e, f.hooks[t])), null != o && o.domain && o.domain.hooks.domain(s), s;\n}\nfunction w(e) {\n  je(e);\n  let t = R in e ? e[R]() : e;\n  r(t.subscribe, 'expect observable to have .subscribe');\n  let n = d(),\n    a = kt(n);\n  return t.subscribe({\n    next: n,\n    error: a,\n    complete: a\n  }), n;\n}\nfunction S(e, t) {\n  Me(e, 'merge', 'first argument');\n  let r = d({\n    name: o(e, 'merge'),\n    derived: 1,\n    and: t\n  });\n  return wt(e, r, [], 'merge'), r;\n}\nfunction x(e, n) {\n  let a = 0;\n  return t(Nt, t => {\n    t in e && (r(null != e[t], Ft(n, t)), a = 1);\n  }), a;\n}\nfunction z() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n  let t,\n    r,\n    n,\n    a,\n    [[i, o, l], s] = f(e),\n    u = 1;\n  return $e(o) && xe(i) && x(i, \"sample\") && (o = i.clock, l = i.fn, u = !i.greedy, a = i.filter, t = i.target, r = i.name, n = i.sid, i = i.source), Dt(\"sample\", o, i, a, t, l, r, s, u, 1, 0, n);\n}\nfunction $() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n  let [[t, r], n] = f(e);\n  return r || (r = t, t = r.source), x(r, 'guard'), Dt('guard', r.clock, t, r.filter, r.target, null, r.name, n, !r.greedy, 0, 1);\n}\nfunction j(t, r, n) {\n  if (Z(t)) return se(0, 'restore($store)'), t;\n  if (ee(t) || te(t)) {\n    let e = U(t),\n      a = p(r, {\n        parent: e,\n        name: t.shortName,\n        and: n\n      });\n    return wt(te(t) ? t.doneData : t, a), e && e.hooks.store(a), a;\n  }\n  let a = Array.isArray(t) ? [] : {};\n  return e(t, (e, t) => a[t] = Z(e) ? e : p(e, {\n    name: t\n  })), a;\n}\nfunction C() {\n  for (var _len8 = arguments.length, t = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    t[_key8] = arguments[_key8];\n  }\n  let n,\n    i,\n    o = 'split',\n    [[l, s], c] = f(t),\n    p = !s;\n  p && (n = l.cases, s = l.match, i = l.clock, l = l.source);\n  let m = Z(s),\n    g = !X(s) && ze(s),\n    h = !m && !g && xe(s);\n  r(X(l), 'source must be a unit'), n || (n = {}), p ? e(n, (e, t) => Ae(o, e, `cases.${t}`)) : (r(h, 'match should be an object'), e(s, (e, t) => n[t] = d({\n    derived: 1,\n    and: c\n  })), n.__ = d({\n    derived: 1,\n    and: c\n  }));\n  let y,\n    b = new Set([].concat(l, i || [], Object.values(n))),\n    v = Object.keys(m || g ? n : s);\n  if (m || g) m && b.add(s), y = [m && _e(B(s), 0, 1), Ee({\n    safe: m,\n    filter: 1,\n    pure: !m,\n    fn(e, t, r) {\n      let n = String(m ? r.a : s(e));\n      Pt(t, ie(v, n) ? n : '__', e, r);\n    }\n  })];else if (h) {\n    let t = Te({});\n    t.type = 'shape';\n    let r,\n      n = [];\n    e(s, (e, a) => {\n      if (X(e)) {\n        r = 1, le(n, a), b.add(e);\n        let i = wt(e, [], [_e(t), Pe((e, t, _ref8) => {\n          let {\n            a: r\n          } = _ref8;\n          return r[a] = e;\n        })]);\n        if (Z(e)) {\n          t.current[a] = e.getState();\n          let r = B(e);\n          We(t, {\n            from: r,\n            field: a,\n            type: 'field'\n          }), u('splitMatchStore', r, i);\n        }\n      }\n    }), r && u('splitBase', t), y = [r && _e(t, 0, 1), Ve((e, t, r) => {\n      for (let a = 0; a < v.length; a++) {\n        let i = v[a];\n        if (ie(n, i) ? r.a[i] : s[i](e)) return void Pt(t, i, e, r);\n      }\n      Pt(t, '__', e, r);\n    }, 1)];\n  } else r(0, 'expect match to be unit, function or object');\n  let k = a({\n    meta: {\n      op: o\n    },\n    parent: i ? [] : l,\n    scope: n,\n    node: y,\n    family: {\n      owners: Array.from(b)\n    },\n    regional: 1\n  });\n  if (i && Dt(o, i, l, null, k, null, o, c, 0, 0, 0), !p) return n;\n}\nfunction M(e) {\n  let {\n    scope: t,\n    params: r\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!X(e)) return Promise.reject(new Error('first argument should be unit'));\n  if (!(te(e) || ee(e) || Z(e) || ne(e))) return Promise.reject(new Error('first argument accepts only effects, events, stores or scopes'));\n  ne(e) && (t = e);\n  let n = h();\n  n.parentFork = et;\n  let {\n    fxCount: a\n  } = t;\n  le(a.scope.defers, n);\n  let o = [],\n    l = [];\n  return ne(e) || (le(o, e), le(l, te(e) ? {\n    params: r,\n    req: {\n      rs(e) {\n        n.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj(e) {\n        n.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  } : r)), le(o, a), le(l, null), i({\n    target: o,\n    params: l,\n    scope: t\n  }), n.req;\n}\nfunction A(e, r) {\n  let n = [];\n  (function e(a) {\n    ie(n, a) || (le(n, a), \"store\" === J(a, 'op') && J(a, 'sid') && r(a, J(a, 'sid')), t(a.next, e), t(L(a), e), t(T(a), e));\n  })(e);\n}\nfunction I(e, n) {\n  let a = Array.isArray(e) ? new Map(e) : e;\n  if (a instanceof Map) {\n    let e = {};\n    return t(a, (t, a) => {\n      r(X(a), 'Map key should be a unit'), n && n(a, t), r(a.sid, 'unit should have a sid'), r(!(a.sid in e), 'duplicate sid found'), e[a.sid] = t;\n    }), e;\n  }\n  return a;\n}\nfunction O(e, n) {\n  let i,\n    o = e;\n  re(e) && (i = e, o = n);\n  let l = (e => {\n    let r = a({\n        scope: {\n          defers: [],\n          inFlight: 0,\n          fxID: 0\n        },\n        node: [Pe((e, t, r) => {\n          U(r) ? 'dec' === J(U(r).node, 'needFxCounter') ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }), Ee({\n          priority: \"sampler\",\n          batch: 1\n        }), Pe((e, r) => {\n          let {\n            defers: n,\n            fxID: a\n          } = r;\n          r.inFlight > 0 || 0 === n.length || Promise.resolve().then(() => {\n            r.fxID === a && t(n.splice(0, n.length), e => {\n              ot(e.parentFork), e.rs(e.value);\n            });\n          });\n        }, 0, 1)]\n      }),\n      n = a({\n        node: [Pe((e, t, r) => {\n          let n = U(r);\n          if (n) {\n            let t = n.node;\n            if (!J(t, 'isCombine') || U(n) && 'combine' !== J(U(n).node, 'op')) {\n              let n = G(r),\n                a = t.scope.state.id,\n                i = J(t, 'sid');\n              n.sidIdMap[i] = a, n.sidValuesMap[i] = e;\n              let o = J(t, 'serialize');\n              o && n.sidSerializeSettings.set(i, 'ignore' === o ? {\n                ignore: 1\n              } : {\n                ignore: 0,\n                write: o.write\n              });\n            }\n          }\n        })]\n      }),\n      i = a({\n        node: [Pe((e, t, r) => {\n          let n = G(r);\n          if (n) {\n            let e = U(r);\n            e && (!J(e.node, 'isCombine') || U(e) && 'combine' !== J(U(e).node, 'op')) && (n.warnSerialize = 1);\n          }\n        })]\n      }),\n      o = {\n        cloneOf: e,\n        reg: {},\n        sidValuesMap: {},\n        sidIdMap: {},\n        sidSerializeSettings: new Map(),\n        getState(e) {\n          if ('current' in e) return ut(at, o, null, e).current;\n          let t = V(e);\n          return ut(at, o, t, t.scope.state, 1).current;\n        },\n        kind: \"scope\",\n        graphite: a({\n          family: {\n            type: \"domain\",\n            links: [r, n, i]\n          },\n          meta: {\n            unit: 'fork'\n          },\n          scope: {\n            forkInFlightCounter: r\n          }\n        }),\n        additionalLinks: {},\n        handlers: {},\n        fxCount: r,\n        storeChange: n,\n        warnSerializeNode: i,\n        activeEffects: []\n      };\n    return o;\n  })(i);\n  if (o) {\n    let e = o.scope;\n    if (e) {\n      let r = e.activeEffects;\n      e.activeEffects = [], l.activeEffects = r, t(r, e => e.ref = l);\n    }\n    if (o.values) {\n      let e = I(o.values, e => r(Z(e), 'Values map can contain only stores as keys'));\n      Object.assign(l.sidValuesMap, e), l.fromSerialize = !(Array.isArray(o.values) || o.values instanceof Map);\n    }\n    o.handlers && (l.handlers = I(o.handlers, e => r(te(e), \"Handlers map can contain only effects as keys\")));\n  }\n  return l;\n}\nfunction q(e, _ref9) {\n  let {\n    values: t\n  } = _ref9;\n  r(xe(t), 'values property should be an object');\n  let n,\n    a,\n    o,\n    l = I(t),\n    s = Object.getOwnPropertyNames(l),\n    f = [],\n    u = [];\n  ne(e) ? (n = e, o = 1, r(n.cloneOf, 'scope should be created from domain'), a = V(n.cloneOf)) : re(e) ? a = V(e) : r(0, 'first argument of hydrate should be domain or scope'), A(a, (e, t) => {\n    if (ie(s, t)) {\n      le(f, e);\n      let r = J(e, 'serialize');\n      r && 'ignore' !== r && (l[t] = r.read(l[t])), le(u, l[t]);\n    }\n  }), i({\n    target: f,\n    params: u,\n    scope: n\n  }), o && Object.assign(n.sidValuesMap, l);\n}\nfunction N(e) {\n  let {\n    scope: t,\n    safe: n\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  r(t || et || n, 'scopeBind cannot be called outside of forked .watch');\n  let a = t || et;\n  return te(e) ? t => {\n    let r = h();\n    return i({\n      target: e,\n      params: {\n        params: t,\n        req: r\n      },\n      scope: a\n    }), r.req;\n  } : t => (i({\n    target: e,\n    params: t,\n    scope: a\n  }), t);\n}\nfunction F(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  t.warnSerialize && console.error('There is a store without sid in this scope, its value is omitted');\n  let a = n.ignore ? n.ignore.map(_ref10 => {\n      let {\n        sid: e\n      } = _ref10;\n      return e;\n    }) : [],\n    i = {};\n  return e(t.sidValuesMap, (e, r) => {\n    var n;\n    if (ie(a, r)) return;\n    let o = t.sidIdMap[r],\n      l = null !== (n = t.sidSerializeSettings.get(r)) && void 0 !== n ? n : {\n        ignore: 0,\n        write: Vt\n      };\n    l.ignore || (i[r] = (0, l.write)(o && o in t.reg ? t.reg[o].current : e));\n  }), 'onlyChanges' in n && !n.onlyChanges && (r(t.cloneOf, 'scope should be created from domain'), A(V(t.cloneOf), (e, r) => {\n    r in i || ie(a, r) || J(e, 'isCombine') || 'ignore' === J(e, 'serialize') || (i[r] = t.getState(e));\n  })), i;\n}\nfunction D(_ref11) {\n  let {\n    unit: e,\n    fn: t,\n    scope: r\n  } = _ref11;\n  let n = [Le.run({\n    fn: e => t(e)\n  })];\n  if (r) {\n    let t = a({\n        node: n\n      }),\n      i = e.graphite.id,\n      o = r.additionalLinks,\n      l = o[i] || [];\n    return o[i] = l, l.push(t), E(() => {\n      let e = l.indexOf(t);\n      -1 !== e && l.splice(e, 1), vt(t);\n    });\n  }\n  {\n    let t = a({\n      node: n,\n      parent: [e],\n      family: {\n        owners: e\n      }\n    });\n    return E(() => {\n      vt(t);\n    });\n  }\n}\nfunction E(e) {\n  let t = () => e();\n  return t.unsubscribe = () => e(), t;\n}\nlet R = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n  P = 'map',\n  _ = 'stack',\n  V = e => e.graphite || e,\n  L = e => e.family.owners,\n  T = e => e.family.links,\n  B = e => e.stateRef,\n  W = e => e.value,\n  H = e => e.subscribers,\n  U = e => e.parent,\n  G = e => e.scope,\n  J = (e, t) => V(e).meta[t],\n  K = (e, t, r) => V(e).meta[t] = r,\n  Q = e => e.compositeName,\n  X = e => (ze(e) || xe(e)) && 'kind' in e;\nconst Y = e => t => X(t) && t.kind === e;\nlet Z = Y(\"store\"),\n  ee = Y(\"event\"),\n  te = Y(\"effect\"),\n  re = Y(\"domain\"),\n  ne = Y(\"scope\");\nvar ae = {\n  __proto__: null,\n  unit: X,\n  store: Z,\n  event: ee,\n  effect: te,\n  domain: re,\n  scope: ne,\n  attached: e => te(e) && 1 == J(e, 'attached')\n};\nlet ie = (e, t) => e.includes(t),\n  oe = (e, t) => {\n    let r = e.indexOf(t);\n    -1 !== r && e.splice(r, 1);\n  },\n  le = (e, t) => e.push(t),\n  se = (e, t, r) => !e && console.error(`${t} is deprecated${r ? `, use ${r} instead` : ''}`);\nconst fe = () => {\n  let e = 0;\n  return () => \"\" + ++e;\n};\nlet ue,\n  de = fe(),\n  ce = fe(),\n  pe = fe(),\n  me = fe(),\n  ge = e => {\n    ue = e;\n  },\n  he = null,\n  ye = e => {\n    ue && ue(e, he);\n  },\n  be = () => he && he.template,\n  ve = e => (e && he && he.sidRoot && (e = `${he.sidRoot}|${e}`), e),\n  ke = _ref12 => {\n    let {\n      sid: e,\n      name: t,\n      loc: r,\n      method: i,\n      fn: o\n    } = _ref12;\n    return n(a({\n      meta: {\n        sidRoot: ve(e),\n        sid: e,\n        name: t,\n        loc: r,\n        method: i,\n        type: 'factory'\n      }\n    }), o);\n  },\n  we = (e, r) => {\n    let n = V(e);\n    t(r, e => {\n      let t = V(e);\n      \"domain\" !== n.family.type && (t.family.type = \"crosslink\"), le(L(t), n), le(T(n), t);\n    });\n  },\n  Se = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return (Array.isArray(e) ? e : [e]).flat().map(V);\n  },\n  xe = e => 'object' == typeof e && null !== e,\n  ze = e => 'function' == typeof e,\n  $e = e => void 0 === e,\n  je = e => r(xe(e) || ze(e), 'expect first argument be an object');\nconst Ce = (e, t, n, a) => r(!(!xe(e) && !ze(e) || !('family' in e) && !('graphite' in e)), `${t}: expect ${n} to be a unit (store, event or effect)${a}`);\nlet Me = (e, r, n) => {\n    Array.isArray(e) ? t(e, (e, t) => Ce(e, r, `${t} item of ${n}`, '')) : Ce(e, r, n, ' or array of units');\n  },\n  Ae = function (e, r) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"target\";\n    return t(Se(r), t => se(!J(t, 'derived'), `${e}: derived unit in \"${n}\"`, \"createEvent/createStore\"));\n  },\n  Ie = (e, _ref13, _ref14) => {\n    let {\n      fn: t\n    } = _ref13;\n    let {\n      a: r\n    } = _ref14;\n    return t(e, r);\n  },\n  Oe = (e, _ref15, _ref16) => {\n    let {\n      fn: t\n    } = _ref15;\n    let {\n      a: r\n    } = _ref16;\n    return t(r, e);\n  },\n  qe = (e, _ref17) => {\n    let {\n      fn: t\n    } = _ref17;\n    return t(e);\n  };\nconst Ne = (e, t, r, n) => {\n  let a = {\n    id: ce(),\n    type: e,\n    data: t\n  };\n  return r && (a.order = {\n    priority: r\n  }, n && (a.order.barrierID = ++Fe)), a;\n};\nlet Fe = 0,\n  De = _ref18 => {\n    let {\n      from: e = \"store\",\n      store: t,\n      target: r,\n      to: n = r ? \"store\" : _,\n      batch: a,\n      priority: i\n    } = _ref18;\n    return Ne('mov', {\n      from: e,\n      store: t,\n      to: n,\n      target: r\n    }, i, a);\n  },\n  Ee = _ref19 => {\n    let {\n      fn: e,\n      batch: t,\n      priority: r,\n      safe: n = 0,\n      filter: a = 0,\n      pure: i = 0\n    } = _ref19;\n    return Ne('compute', {\n      fn: e,\n      safe: n,\n      filter: a,\n      pure: i\n    }, r, t);\n  },\n  Re = _ref20 => {\n    let {\n      fn: e\n    } = _ref20;\n    return Ee({\n      fn: e,\n      priority: \"effect\"\n    });\n  },\n  Pe = (e, t, r) => Ee({\n    fn: e,\n    safe: 1,\n    filter: t,\n    priority: r && \"effect\"\n  }),\n  _e = (e, t, r) => De({\n    store: e,\n    to: t ? _ : \"a\",\n    priority: r && \"sampler\",\n    batch: 1\n  }),\n  Ve = function () {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : qe;\n    let t = arguments.length > 1 ? arguments[1] : undefined;\n    return Ee({\n      fn: e,\n      pure: 1,\n      filter: t\n    });\n  },\n  Le = {\n    mov: De,\n    compute: Ee,\n    filter: _ref21 => {\n      let {\n        fn: e,\n        pure: t\n      } = _ref21;\n      return Ee({\n        fn: e,\n        filter: 1,\n        pure: t\n      });\n    },\n    run: Re\n  },\n  Te = e => ({\n    id: ce(),\n    current: e\n  }),\n  Be = _ref22 => {\n    let {\n      current: e\n    } = _ref22;\n    return e;\n  },\n  We = (e, t) => {\n    e.before || (e.before = []), le(e.before, t);\n  },\n  He = null;\nconst Ue = (e, t) => {\n    if (!e) return t;\n    if (!t) return e;\n    let r;\n    return (e.v.type === t.v.type && e.v.id > t.v.id || Ye(e.v.type) > Ye(t.v.type)) && (r = e, e = t, t = r), r = Ue(e.r, t), e.r = e.l, e.l = r, e;\n  },\n  Ge = [];\nlet Je = 0;\nfor (; Je < 6;) le(Ge, {\n  first: null,\n  last: null,\n  size: 0\n}), Je += 1;\nconst Ke = () => {\n    for (let e = 0; e < 6; e++) {\n      let t = Ge[e];\n      if (t.size > 0) {\n        if (3 === e || 4 === e) {\n          t.size -= 1;\n          let e = He.v;\n          return He = Ue(He.l, He.r), e;\n        }\n        1 === t.size && (t.last = null);\n        let r = t.first;\n        return t.first = r.r, t.size -= 1, r.v;\n      }\n    }\n  },\n  Qe = (e, t, r, n, a, i, o) => Xe(0, {\n    a: null,\n    b: null,\n    node: r,\n    parent: n,\n    value: a,\n    page: t,\n    scope: i,\n    meta: o\n  }, e),\n  Xe = function (e, t, r) {\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let a = Ye(r),\n      i = Ge[a],\n      o = {\n        v: {\n          idx: e,\n          stack: t,\n          type: r,\n          id: n\n        },\n        l: null,\n        r: null\n      };\n    3 === a || 4 === a ? He = Ue(He, o) : (0 === i.size ? i.first = o : i.last.r = o, i.last = o), i.size += 1;\n  },\n  Ye = e => {\n    switch (e) {\n      case 'child':\n        return 0;\n      case 'pure':\n        return 1;\n      case 'read':\n        return 2;\n      case \"barrier\":\n        return 3;\n      case \"sampler\":\n        return 4;\n      case \"effect\":\n        return 5;\n      default:\n        return -1;\n    }\n  },\n  Ze = new Set();\nlet et,\n  tt = 1,\n  rt = 0,\n  nt = 0,\n  at = null,\n  ot = e => {\n    et = e;\n  },\n  lt = e => {\n    at = e;\n  };\nconst st = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = U(e);\n    if (e) return e;\n  }\n  return null;\n};\nlet ft,\n  ut = (e, t, r, n, a) => {\n    let i = st(e, n.id);\n    return i ? i.reg[n.id] : t ? (pt(t, n, a), t.reg[n.id]) : n;\n  },\n  dt = e => {\n    ft = e;\n  };\nconst ct = e => e;\nlet pt = (e, r, n, a, i) => {\n  var o;\n  let l = e.reg,\n    s = r.sid,\n    f = null == r || null === (o = r.meta) || void 0 === o ? void 0 : o.serialize;\n  if (l[r.id]) return;\n  let u = {\n    id: r.id,\n    current: r.current,\n    meta: r.meta\n  };\n  if (s && s in e.sidValuesMap && !(s in e.sidIdMap)) u.current = (e.fromSerialize && 'ignore' !== f && (null == f ? void 0 : f.read) || ct)(e.sidValuesMap[s]);else if (r.before && !i) {\n    let i = 0,\n      o = n || !r.noInit || a;\n    t(r.before, t => {\n      switch (t.type) {\n        case P:\n          {\n            let r = t.from;\n            if (r || t.fn) {\n              r && pt(e, r, n, a);\n              let i = r && l[r.id].current;\n              o && (u.current = t.fn ? t.fn(i) : i);\n            }\n            break;\n          }\n        case 'field':\n          i || (i = 1, u.current = Array.isArray(u.current) ? [...u.current] : {\n            ...u.current\n          }), pt(e, t.from, n, a), o && (u.current[t.field] = l[l[t.from.id].id].current);\n      }\n    });\n  }\n  s && (e.sidIdMap[s] = r.id), l[r.id] = u;\n};\nconst mt = (e, t, r) => {\n  try {\n    return t(W(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1, e.failReason = t;\n  }\n};\nlet gt = function (t) {\n  let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return xe(t) && (gt(t.or, r), e(t, (e, t) => {\n    $e(e) || 'or' === t || 'and' === t || (r[t] = e);\n  }), gt(t.and, r)), r;\n};\nconst ht = (e, t) => {\n    oe(e.next, t), oe(L(e), t), oe(T(e), t);\n  },\n  yt = (e, t, r) => {\n    let n;\n    e.next.length = 0, e.seq.length = 0, e.scope = null;\n    let a = T(e);\n    for (; n = a.pop();) ht(n, e), (t || r && 'sample' !== J(e, 'op') || \"crosslink\" === n.family.type) && yt(n, t, 'on' !== J(n, 'op') && r);\n    for (a = L(e); n = a.pop();) ht(n, e), r && \"crosslink\" === n.family.type && yt(n, t, 'on' !== J(n, 'op') && r);\n  },\n  bt = e => e.clear();\nlet vt = function (e) {\n    let {\n      deep: t\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let r = 0;\n    if (e.ownerSet && e.ownerSet.delete(e), Z(e)) bt(H(e));else if (re(e)) {\n      r = 1;\n      let t = e.history;\n      bt(t.events), bt(t.effects), bt(t.stores), bt(t.domains);\n    }\n    yt(V(e), !!t, r);\n  },\n  kt = e => {\n    let t = () => vt(e);\n    return t.unsubscribe = t, t;\n  },\n  wt = (e, t, r, n, i) => a({\n    node: r,\n    parent: e,\n    child: t,\n    scope: {\n      fn: i\n    },\n    meta: {\n      op: n\n    },\n    family: {\n      owners: [e, t],\n      links: t\n    },\n    regional: 1\n  }),\n  St = e => {\n    let t = 'forward',\n      [{\n        from: r,\n        to: n\n      }, i] = f(e, 1);\n    return Me(r, t, '\"from\"'), Me(n, t, '\"to\"'), Ae(t, n, 'to'), kt(a({\n      parent: r,\n      child: n,\n      meta: {\n        op: t,\n        config: i\n      },\n      family: {},\n      regional: 1\n    }));\n  },\n  xt = (e, t) => (r(ze(t), '.watch argument should be a function'), kt(a({\n    scope: {\n      fn: t\n    },\n    node: [Re({\n      fn: qe\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }))),\n  zt = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n    U(e) && U(e).hooks[r](t);\n  },\n  $t = (e, t, r) => {\n    let n = gt(r),\n      a = \"domain\" === e,\n      i = de(),\n      {\n        sid: o = null,\n        named: l = null,\n        domain: f = null,\n        parent: u = f\n      } = n,\n      d = l || n.name || (a ? '' : i),\n      c = s(d, u),\n      p = {\n        op: t.kind = e,\n        name: t.shortName = d,\n        sid: t.sid = ve(o),\n        named: l,\n        unitId: t.id = i,\n        serialize: n.serialize,\n        derived: n.derived,\n        config: n\n      };\n    if (t.parent = u, t.compositeName = c, t.defaultConfig = n, t.thru = e => (se(0, 'thru', 'js pipe'), e(t)), t.getType = () => c.fullName, !a) {\n      t.subscribe = e => (je(e), t.watch(ze(e) ? e : t => e.next && e.next(t))), t[R] = () => t;\n      let e = be();\n      e && (p.nativeTemplate = e);\n    }\n    return p;\n  };\nconst jt = (e, t, r, n) => {\n    let a;\n    xe(r) && (a = r, r = r.fn);\n    let i = d({\n      name: `${e.shortName} \\u2192 *`,\n      derived: 1,\n      and: a\n    });\n    return wt(e, i, n, t, r), i;\n  },\n  Ct = (e, t, r, n, a) => {\n    let i = B(t),\n      o = De({\n        store: i,\n        to: \"a\",\n        priority: 'read'\n      });\n    r === P && (o.data.softRead = 1);\n    let l = [o, Ve(n)];\n    return u('storeOnMap', i, l, Z(e) && B(e)), wt(e, t, l, r, a);\n  },\n  Mt = (t, n, a, i, l) => {\n    let s = t ? e => [...e] : e => ({\n        ...e\n      }),\n      f = t ? [] : {},\n      d = s(f),\n      c = Te(d),\n      m = Te(1);\n    c.type = t ? 'list' : 'shape', c.noInit = 1, u('combineBase', c, m);\n    let g = p(d, {\n        name: o(a),\n        derived: 1,\n        and: i\n      }),\n      h = B(g);\n    h.noInit = 1, K(g, 'isCombine', 1);\n    let y = _e(c);\n    y.order = {\n      priority: 'barrier'\n    };\n    let b = [Pe((e, t, r) => (r.scope && !r.scope.reg[c.id] && (r.c = 1), e)), y, De({\n      store: m,\n      to: 'b'\n    }), Pe((e, _ref23, r) => {\n      let {\n        key: t\n      } = _ref23;\n      if (r.c || e !== r.a[t]) return n && r.b && (r.a = s(r.a)), r.a[t] = e, 1;\n    }, 1), De({\n      from: \"a\",\n      target: c\n    }), De({\n      from: \"value\",\n      store: 0,\n      target: m\n    }), De({\n      from: \"value\",\n      store: 1,\n      target: m,\n      priority: \"barrier\",\n      batch: 1\n    }), _e(c, 1), l && Ve()];\n    return e(a, (e, t) => {\n      if (!Z(e)) return r(!X(e) && !$e(e), `combine expects a store in a field ${t}`), void (d[t] = f[t] = e);\n      f[t] = e.defaultState, d[t] = e.getState();\n      let n = wt(e, g, b, 'combine', l);\n      n.scope.key = t;\n      let a = B(e);\n      We(c, {\n        type: 'field',\n        field: t,\n        from: a\n      }), u('combineField', a, n);\n    }), g.defaultShape = a, We(h, {\n      type: P,\n      from: c,\n      fn: l\n    }), be() || (g.defaultState = l ? h.current = l(d) : f), g;\n  };\nlet At = (e, t, r) => {\n    try {\n      return [1, e(...r)];\n    } catch (e) {\n      return t(e), [0, null];\n    }\n  },\n  It = e => {\n    let t = G(e),\n      r = {\n        ref: t\n      };\n    return t && le(t.activeEffects, r), r;\n  },\n  Ot = (e, t, r, n, a, o) => l => {\n    o.ref && oe(o.ref.activeEffects, o), i({\n      target: [n, qt],\n      params: [r ? {\n        status: 'done',\n        params: e,\n        result: l\n      } : {\n        status: 'fail',\n        params: e,\n        error: l\n      }, {\n        value: l,\n        fn: r ? t.rs : t.rj\n      }],\n      defer: 1,\n      page: a.page,\n      scope: o.ref,\n      meta: a.meta\n    });\n  };\nconst qt = a({\n    node: [Re({\n      fn: _ref24 => {\n        let {\n          fn: e,\n          value: t\n        } = _ref24;\n        return e(t);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'sidechain'\n    }\n  }),\n  Nt = ['source', 'clock', 'target'],\n  Ft = (e, t) => e + `: ${t} should be defined`;\nlet Dt = (e, t, n, a, i, o, l, s, f, c, g, h) => {\n  let y = !!i;\n  r(!$e(n) || !$e(t), Ft(e, 'either source or clock'));\n  let b = 0;\n  $e(n) ? b = 1 : X(n) || (n = m(n)), $e(t) ? t = n : (Me(t, e, 'clock'), Array.isArray(t) && (t = S(t))), b && (n = t), s || l || (l = n.shortName);\n  let v = 'none';\n  (g || a) && (X(a) ? v = 'unit' : (r(ze(a), '`filter` should be function or unit'), v = 'fn')), i ? (Me(i, e, 'target'), Ae(e, i)) : 'none' === v && c && Z(n) && Z(t) ? i = p(o ? o(Be(B(n)), Be(B(t))) : Be(B(n)), {\n    name: l,\n    sid: h,\n    or: s\n  }) : (i = d({\n    name: l,\n    derived: 1,\n    or: s\n  }), u('sampleTarget', V(i)));\n  let k = Te(),\n    w = [];\n  if ('unit' === v) {\n    let [r, n] = Rt(a, i, t, k, e);\n    w = [...Et(n), ...Et(r)];\n  }\n  let [x, z] = Rt(n, i, t, k, e),\n    $ = wt(t, i, [u('sampleSourceLoader'), De({\n      from: _,\n      target: k\n    }), ...Et(z), _e(x, 1, f), ...w, _e(k), 'fn' === v && Ve((e, t, _ref25) => {\n      let {\n        a: r\n      } = _ref25;\n      return a(e, r);\n    }, 1), o && Ve(Ie), u('sampleSourceUpward', y)], e, o);\n  return we(n, [$]), Object.assign($.meta, s, {\n    joint: 1\n  }), i;\n};\nconst Et = e => [_e(e), Pe((e, t, _ref26) => {\n    let {\n      a: r\n    } = _ref26;\n    return r;\n  }, 1)],\n  Rt = (e, t, r, n, i) => {\n    let o = Z(e),\n      l = o ? B(e) : Te(),\n      s = Te(o);\n    return o || a({\n      parent: e,\n      node: [De({\n        from: _,\n        target: l\n      }), De({\n        from: \"value\",\n        store: 1,\n        target: s\n      })],\n      family: {\n        owners: [e, t, r],\n        links: t\n      },\n      meta: {\n        op: i\n      },\n      regional: 1\n    }), u('sampleSource', s, l, n), [l, s];\n  },\n  Pt = (e, t, r, n) => {\n    let a = e[t];\n    a && i({\n      target: a,\n      params: Array.isArray(a) ? a.map(() => r) : r,\n      defer: 1,\n      stack: n\n    });\n  },\n  _t = \"22.7.0\",\n  Vt = e => e;\nexport { M as allSettled, b as attach, vt as clearNode, m as combine, v as createApi, k as createDomain, y as createEffect, d as createEvent, a as createNode, p as createStore, g as createStoreObject, D as createWatch, O as fork, St as forward, w as fromObservable, $ as guard, q as hydrate, ae as is, i as launch, S as merge, j as restore, z as sample, N as scopeBind, F as serialize, ge as setGraphInspector, dt as setInspector, l as setStoreName, C as split, Le as step, _t as version, ke as withFactory, n as withRegion };","map":{"version":3,"names":["e","t","r","forEach","Error","n","V","meta","he","id","parent","value","template","be","sidRoot","ye","U","a","node","from","source","to","i","target","o","child","l","scope","s","f","family","u","type","regional","d","arguments","length","undefined","c","Se","p","links","m","owners","g","le","h","pe","seq","next","L","T","we","W","at","et","params","defer","page","stack","G","Array","isArray","Qe","tt","isRoot","currentPage","isWatch","rt","isPure","nt","Ke","idx","reg","fail","order","priority","barrierID","fullID","Ze","has","add","Xe","delete","data","_","store","st","pt","softRead","Be","ut","current","fn","J","pure","safe","mt","filter","ft","fxCount","storeChange","warnSerializeNode","additionalLinks","X","Q","fullName","toString","shortName","Object","assign","path","concat","je","or","and","xe","handlers","_len","_key","gt","name","event","_len2","_key2","se","lt","create","graphite","$t","actualOp","watch","xt","map","jt","P","Ve","qe","filterMap","Pe","$e","prepend","wt","zt","domain","hooks","Me","ze","off","H","set","kt","Ct","Oe","Te","named","derived","subscribers","Map","updates","defaultState","stateRef","getState","setState","reset","_len3","_key3","on","get","Ie","We","B","noInit","defaultConfig","updateFilter","state","b","_e","_ref","De","y","v","k","w","K","sid","serialize","reinit","_len4","_key4","slice","Z","Mt","req","Promise","rs","rj","catch","handler","kind","use","getCurrent","finally","done","_ref2","status","result","_ref3","error","doneData","_ref4","failData","_ref5","handlerId","getType","_ref6","args","It","Ot","At","then","op","fx","runner","_ref7","fxID","me","ot","inFlight","pending","effect","mapParams","te","splice","_len5","_key5","config","history","Event","Effect","Store","Domain","toLowerCase","Set","ownerSet","R","subscribe","complete","S","x","Nt","Ft","z","_len6","_key6","clock","greedy","Dt","$","_len7","_key7","j","ee","C","_len8","_key8","cases","match","Ae","__","values","keys","Ee","String","Pt","ie","_ref8","field","M","reject","ne","parentFork","defers","A","I","O","re","batch","resolve","sidIdMap","sidValuesMap","sidSerializeSettings","ignore","write","warnSerialize","cloneOf","unit","forkInFlightCounter","activeEffects","ref","fromSerialize","q","_ref9","getOwnPropertyNames","read","N","F","console","_ref10","Vt","onlyChanges","D","_ref11","Le","run","push","E","indexOf","vt","subscription","unsubscribe","Symbol","observable","getMeta","setMeta","compositeName","Y","ae","__proto__","attached","includes","oe","removeItem","deprecate","fe","idCount","ue","de","ce","ge","readTemplate","ve","ke","_ref12","loc","method","own","arrifyNodes","flat","Ce","assertNodeSetItem","assertNodeSet","assertTarget","callStackAReg","_ref13","_ref14","callARegStack","_ref15","_ref16","callStack","_ref17","Ne","cmd","Fe","_ref18","_ref19","Re","_ref20","calc","userFnCall","mov","compute","_ref21","_ref22","addRefOp","before","He","Ue","merge","Ye","Ge","Je","first","last","size","deleteMin","pushFirstHeapItem","pushHeap","getPageForRef","getPageRef","dt","ct","initRefInScope","tryRun","failReason","flattenConfig","ht","removeFromNode","yt","clearNodeNormalized","pop","bt","clear","clearNode","deep","events","effects","stores","domains","createLinkNode","St","watchUnit","applyParentHook","initUnit","unitId","thru","nativeTemplate","deriveEvent","updateStore","storeCombination","_ref23","key","defaultShape","runFn","onSettled","qt","_ref24","fieldErrorMessage","createSampling","Rt","Et","_ref25","joint","_ref26","syncSourceState","launchCase","_t","allSettled","attach","combine","createApi","createDomain","createEffect","createEvent","createNode","createStore","createStoreObject","createWatch","fork","forward","fromObservable","guard","hydrate","is","launch","restore","sample","scopeBind","setGraphInspector","setInspector","setStoreName","split","step","version","withFactory","withRegion"],"sources":["/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/collection.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/throw.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/region.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createNode.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/tag.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/kernel.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/naming.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/config.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/template.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createUnit.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/combine.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/defer.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createEffect.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/attach.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createApi.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createDomain.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fromObservable.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/merge.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/sample.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/guard.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/restore.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/split.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/allSettled.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/util.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/fork.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/createScope.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/hydrate.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/scopeBind.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/fork/serialize.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/createWatch.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/observable.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/getter.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/validate.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/id.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/own.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/is.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/caller.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/step.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/stateRef.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/clearNode.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/subscription.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/forward.ts","/Users/ilya/Downloads/meta-smart-front/node_modules/effector/effector/watch.ts"],"sourcesContent":["export function forIn<T, Key extends string = string>(\n  obj: Record<Key, T>,\n  cb: (value: T, key: Key) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import type {Template} from '../forest/index.h'\nimport type {NodeUnit, Node, ID} from './index.h'\nimport {getParent, getGraph} from './getter'\nimport {createNode} from './createNode'\n\ntype DeclarationSourceReporter = (\n  node: Node | 'region',\n  regionStack: RegionStack | null,\n) => void\n\nlet reporter: DeclarationSourceReporter\n\nexport const setGraphInspector = (fn: DeclarationSourceReporter) => {\n  reporter = fn\n}\n\ntype RegionStack = {\n  id: ID\n  parent: RegionStack | null\n  value: any\n  template: Template | null\n  sidRoot?: string\n  meta:\n    | Record<string, unknown>\n    | {\n        type: 'factory'\n        sid?: string\n        name?: string\n        loc: unknown\n        method?: string\n      }\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const reportDeclaration = (node: Node | 'region') => {\n  if (reporter) {\n    reporter(node, regionStack)\n  }\n}\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion<T = void>(unit: NodeUnit, cb: () => T): T {\n  const meta = getGraph(unit).meta || {}\n\n  regionStack = {\n    id: getGraph(unit).id,\n    parent: regionStack,\n    value: unit,\n    template: meta.template || readTemplate(),\n    sidRoot: meta.sidRoot || (regionStack && regionStack.sidRoot),\n    meta: meta,\n  }\n  try {\n    return cb()\n  } finally {\n    reportDeclaration('region')\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const factoryRootNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), sid, name, loc, method, type: 'factory'},\n  })\n\n  return withRegion(factoryRootNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef, Stack} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  failReason?: unknown\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n  meta?: Record<string, any> | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n      meta,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope | void | null) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\n/** Introspection api internals */\ntype Inspector = (stack: Stack, local: Local) => void\nlet inspector: Inspector\nexport const setInspector = (newInspector: Inspector) => {\n  inspector = newInspector\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void | null\n  stack?: Stack | void\n  meta?: Record<string, any> | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  let meta: Record<string, any> | void\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    meta = unit.meta\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n        meta,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n      meta,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (inspector) {\n      inspector(stack, local)\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      const forkPage = getForkPage(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem('child', page, nextNode, stack, finalValue, forkPage)\n      })\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'warnSerialize'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.warnSerializeNode,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nconst noopParser = (x: any) => x\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n    fromSerialize?: boolean\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  const serialize = sourceRef?.meta?.serialize\n  const parser =\n    scope.fromSerialize && serialize !== 'ignore'\n      ? serialize?.read || noopParser\n      : noopParser\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n    meta: sourceRef.meta,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = parser(scope.sidValuesMap[sid])\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n    local.failReason = err\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : (unit as any).toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any[],\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: Record<string, any> = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    // @ts-expect-error\n    if (fn) return fn(template, ...args)\n  }\n}\n","import type {Template} from '../forest/index.h'\nimport type {Store, Event, CommonUnit, Effect, Domain} from './unit.h'\nimport type {Subscriber, Config, Cmd, Kind} from './index.h'\n\nimport {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot, reportDeclaration} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: CommonUnit,\n  target: CommonUnit,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: Kind, unit: any, rawConfig: any) => {\n  const config = flattenConfig(rawConfig)\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const {sid = null, named = null, domain = null, parent = domain} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (\n  event: Event<any>,\n  op: 'map' | 'filterMap' | 'filter',\n  fn: Function,\n  node: Cmd[],\n) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = (fn as unknown as {fn: Function}).fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  const finalEvent = Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(config.actualOp || EVENT, event, config),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      //@ts-expect-error\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n  if (config?.domain) {\n    config.domain.hooks.event(finalEvent)\n  }\n  reportDeclaration(finalEvent.graphite)\n  return finalEvent\n}\nfunction on<State>(\n  store: Store<State>,\n  methodName: string,\n  nodeSet: CommonUnit | CommonUnit[],\n  fn: Function,\n) {\n  assertNodeSet(nodeSet, methodName, 'first argument')\n  assert(isFunction(fn), 'second argument should be a function')\n  deprecate(\n    !getMeta(store, 'derived'),\n    `${methodName} in derived store`,\n    `${methodName} in store created via createStore`,\n  )\n  forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n    store.off(trigger)\n    getSubscribers(store).set(\n      trigger,\n      createSubscription(updateStore(trigger, store, 'on', callARegStack, fn)),\n    )\n  })\n  return store\n}\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const config = flattenConfig(props)\n  const plainState = createStateRef(defaultState)\n  const updates = createEvent({named: 'updates', derived: true})\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit =>\n        on(store, '.reset', unit, () => store.defaultState),\n      )\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      return on(store, '.on', nodeSet, fn)\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        // @ts-expect-error some mismatch in config types\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return (eventOrFn as CommonUnit).watch((payload: any) =>\n        fn(store.getState(), payload),\n      )\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, config)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta: {\n      ...meta,\n      defaultState,\n    },\n    regional: true,\n  })\n  const serializeMeta = getMeta(store, 'serialize')\n  const derived = getMeta(store, 'derived')\n  const ignored = serializeMeta === 'ignore'\n  const customSerialize = !serializeMeta || ignored ? false : serializeMeta\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n\n    if (customSerialize) {\n      plainState.meta = {\n        ...plainState?.meta,\n        serialize: customSerialize,\n      }\n    }\n  }\n  if (!sid && !ignored && !derived) {\n    setMeta(store, 'warnSerialize', true)\n  }\n  assert(\n    derived || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  if (config?.domain) {\n    config.domain.hooks.store(store)\n  }\n\n  if (!derived) {\n    store.reinit = createEvent<void>({\n      named: 'reinit',\n    })\n    store.reset(store.reinit)\n  }\n\n  reportDeclaration(store.graphite)\n\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => [...list] : (obj: any) => ({...obj})\n  const defaultState: Record<string, any> = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","import type {Defer} from './unit.h'\n\nexport function createDefer(): Defer {\n  const result = {} as Defer\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(() => {})\n  return result\n}\n","import type {Unit, Stack} from './index.h'\nimport type {Effect, Scope} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add, removeItem} from './collection'\nimport {flattenConfig} from './config'\nimport {nextEffectID} from './id'\n\ntype RunnerData<Params, Done, Fail> = {\n  params: Params\n  req: {\n    rs(data: Done): void\n    rj(data: Fail): void\n  }\n  args?: [params: Params, computedParams: any] | [params: Params]\n  handler?: Function\n}\n\nexport function createEffect<Params, Done, Fail = Error>(\n  nameOrConfig: any,\n  maybeConfig: any = {},\n): Effect<Params, Done, Fail> {\n  const config = flattenConfig(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    {...maybeConfig, actualOp: EFFECT},\n  ) as unknown as Effect<Params, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createEvent({\n    named: 'finally',\n    derived: true,\n  }))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({\n      status,\n      params,\n      result,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({\n      status,\n      params,\n      error,\n    }: {\n      status: 'done' | 'fail'\n      params: Params\n      result: Done\n      error: Fail\n    }) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: {result: Done}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: {error: Fail}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd: RunnerData<Params, Done, Fail>, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        (\n          {\n            params,\n            req,\n            handler,\n            args = [params],\n          }: RunnerData<Params, Done, Fail> & {handler: Function},\n          _,\n          stack,\n        ) => {\n          const scopeRef = createScopeRef(stack)\n          const onResolve = onSettled(\n            params,\n            req,\n            true,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const onReject = onSettled(\n            params,\n            req,\n            false,\n            anyway,\n            stack,\n            scopeRef,\n          )\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd: RunnerData<Params, Done, Fail> = getParent(stack)\n          ? {params, req: {rs(data: Done) {}, rj(data: Fail) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        if (!stack.meta) {\n          stack.meta = {fxID: nextEffectID()}\n        }\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n          meta: stack.meta,\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Params) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n    }\n    launch({\n      target: instance,\n      params: payload,\n      scope: forkPage,\n    })\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {\n    serialize: 'ignore',\n  })\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1)\n    .map({\n      // @ts-expect-error\n      fn: x => x,\n      named: 'inFlight',\n    }))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  if (config?.domain) {\n    config.domain.hooks.effect(instance)\n  }\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const createScopeRef = (stack: Stack) => {\n  const scope = getForkPage(stack)\n  const scopeRef = {ref: scope}\n  if (scope) add(scope.activeEffects, scopeRef)\n  return scopeRef\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): void\n      rj(_: any): void\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n    scopeRef: {ref: Scope | void},\n  ) =>\n  (data: any) => {\n    if (scopeRef.ref) removeItem(scopeRef.ref.activeEffects, scopeRef)\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      // WARN! Will broke forest pages as they arent moved to new scope\n      page: stack.page,\n      scope: scopeRef.ref,\n      meta: stack.meta,\n    })\n  }\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, createScopeRef, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const scopeRef = createScopeRef(stack)\n      const rj = onSettled(params, req, false, anyway, stack, scopeRef)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {\n                rs: onSettled(params, req, true, anyway, stack, scopeRef),\n                rj,\n              },\n            },\n            page: stack.page,\n            defer: true,\n            meta: stack.meta,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createNamedEvent,\n  createStore,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\nimport {flattenConfig} from './config'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const config = flattenConfig({\n    or: maybeConfig,\n    and: typeof nameOrConfig === 'string' ? {name: nameOrConfig} : nameOrConfig,\n  }) as any\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n    parent: config?.domain || config?.parent,\n  })\n\n  const domain = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  } as Domain\n\n  node.meta = initUnit(DOMAIN, domain, {\n    parent: config?.domain || config?.parent,\n    or: config,\n  })\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase() as\n        | 'event'\n        | 'effect'\n        | 'store'\n        | 'domain'\n\n      const onCreateUnit = createNamedEvent(`on${tag}`)\n      domain.hooks[lowerCaseTag] = onCreateUnit\n\n      const history = new Set<any>()\n      domain.history[`${lowerCaseTag}s`] = history\n\n      onCreateUnit.create = unit => {\n        launch(onCreateUnit, unit)\n        return unit\n      }\n      add(\n        getGraph(onCreateUnit).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      onCreateUnit.watch(unit => {\n        own(domain, [unit])\n        history.add(unit)\n        if (!unit.ownerSet) unit.ownerSet = history\n        if (!getParent(unit)) unit.parent = domain\n      })\n      own(domain, [onCreateUnit])\n\n      domain[`onCreate${tag}`] = (hook: (unit: any) => any) => {\n        forEach(history, hook)\n        return onCreateUnit.watch(hook)\n      }\n      domain[`create${tag}`] = domain[lowerCaseTag] = (\n        nameOrConfig: any,\n        rawConfig?: Config,\n      ) => {\n        const config = flattenConfig({and: rawConfig, or: nameOrConfig})\n        if (config?.domain) {\n          // @ts-expect-error complicated factory type\n          return factory(nameOrConfig, rawConfig)\n        }\n        // @ts-expect-error complicated factory type\n        return onCreateUnit(factory(nameOrConfig, {parent: domain, or: config}))\n      }\n    },\n  )\n\n  const parent = getParent(domain)\n  if (parent) {\n    forIn(domain.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  if (config?.domain) {\n    config.domain.hooks.domain(domain)\n  }\n  return domain\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any[]) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  // @ts-expect-error\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      // @ts-expect-error\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      // @ts-expect-error\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    // @ts-expect-error\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  const jointNode = createLinkNode(\n    // @ts-expect-error\n    clock,\n    target,\n    [\n      applyTemplate('sampleSourceLoader'),\n      mov({from: STACK, target: clockState}),\n      ...readAndFilter(hasSource),\n      read(sourceRef, true, batched),\n      ...filterNodes,\n      read(clockState),\n      filterType === 'fn' && userFnCall((src, _, {a}) => filter(src, a), true),\n      fn && userFnCall(callStackAReg),\n      applyTemplate('sampleSourceUpward', isUpward),\n    ],\n    method,\n    fn,\n  )\n  // @ts-expect-error\n  own(source, [jointNode])\n  Object.assign(jointNode.meta, metadata, {joint: true})\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args: any[]) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj: any, defaultState: any, config?: any) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd, Stack} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  assert(is.unit(source), 'source must be a unit')\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        // @ts-expect-error\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope, Event, Effect, DataCarrier, SettledDefer} from '../unit.h'\n\nexport function allSettled<T>(\n  start: Event<T> | Effect<T, any, any> | Scope,\n  //@ts-expect-error its optional in correct cases\n  {scope, params: ctx}: {scope: Scope; params?: unknown} = {},\n) {\n  if (!is.unit(start))\n    return Promise.reject(new Error('first argument should be unit'))\n  if (\n    !is.effect(start) &&\n    !is.event(start) &&\n    !is.store(start) &&\n    !is.scope(start)\n  )\n    return Promise.reject(\n      new Error(\n        'first argument accepts only effects, events, stores or scopes',\n      ),\n    )\n  /** duplicated check because of ts validation */\n  if (is.scope(start)) {\n    scope = start\n  }\n  const defer = createDefer() as SettledDefer\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits: DataCarrier[] = []\n  const launchParams: Array<{params: unknown; req: unknown} | null> = []\n  if (!is.scope(start)) {\n    add(launchUnits, start)\n    add(\n      launchParams,\n      is.effect(start)\n        ? {\n            params: ctx,\n            req: {\n              rs(value: unknown) {\n                defer.value = {status: 'done', value}\n              },\n              rj(value: unknown) {\n                defer.value = {status: 'fail', value}\n              },\n            },\n          }\n        : ctx,\n    )\n  }\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store, Effect, ValuesMap, HandlersMap} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\ntype StoreOrEffect = Store<any> | Effect<any, any, any>\n\nexport function normalizeValues(\n  values: ValuesMap | HandlersMap,\n  assertEach?: (key: StoreOrEffect, value: any) => void,\n) {\n  const mapOrRecordValues: Map<StoreOrEffect, any> | Record<string, any> =\n    Array.isArray(values) ? new Map(values as [StoreOrEffect, any][]) : values\n  if (mapOrRecordValues instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(mapOrRecordValues, (value, key) => {\n      assert(\n        (is.unit as (val: unknown) => val is StoreOrEffect)(key),\n        'Map key should be a unit',\n      )\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return mapOrRecordValues\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain, ValuesMap, HandlersMap, Scope} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\nimport {forEach} from '../collection'\n\ntype ForkConfig = {\n  values?: ValuesMap\n  handlers?: HandlersMap\n  scope?: Scope\n}\n\nexport function fork(\n  domainOrConfig?: Domain | ForkConfig,\n  optionalConfig?: ForkConfig,\n) {\n  let config: ForkConfig | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    const oldScope = config.scope\n    if (oldScope) {\n      const activeEffects = oldScope.activeEffects\n      oldScope.activeEffects = []\n      scope.activeEffects = activeEffects\n      forEach(activeEffects, scopeRef => (scopeRef.ref = scope))\n    }\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n      scope.fromSerialize =\n        !Array.isArray(config.values) && !(config.values instanceof Map)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope, SettledDefer, Store} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (\n          _,\n          scope: {\n            inFlight: number\n            fxID: number\n            defers: SettledDefer[]\n          },\n        ) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            (getParent(storeStack) &&\n              getMeta(getParent(storeStack).node, 'op') !== 'combine')\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n\n            const serialize = getMeta(storeNode, 'serialize')\n            if (serialize) {\n              if (serialize === 'ignore') {\n                forkPage.sidSerializeSettings.set(sid, {ignore: true})\n              } else {\n                forkPage.sidSerializeSettings.set(sid, {\n                  ignore: false,\n                  write: serialize.write,\n                })\n              }\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const warnSerializeNode = createNode({\n    node: [\n      calc((_, __, stack) => {\n        const forkPage = getForkPage(stack)\n        if (forkPage) {\n          const storeStack = getParent(stack)\n          if (storeStack) {\n            const storeNode = storeStack.node\n            if (\n              !getMeta(storeNode, 'isCombine') ||\n              (getParent(storeStack) &&\n                getMeta(getParent(storeStack).node, 'op') !== 'combine')\n            ) {\n              forkPage.warnSerialize = true\n            }\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    sidSerializeSettings: new Map(),\n    getState(store: StateRef | Store<any>) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange, warnSerializeNode],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n    warnSerializeNode,\n    activeEffects: [],\n  }\n  return resultScope\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope, ValuesMap} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: ValuesMap}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      const serializer = getMeta(node, 'serialize')\n      if (serializer && serializer !== 'ignore') {\n        normalizedValues[sid] = serializer.read(normalizedValues[sid])\n      }\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\nimport type {Unit} from '../index.h'\n\n/** bind event to scope */\nexport function scopeBind(\n  unit: Unit,\n  {scope, safe}: {scope?: Scope; safe?: true} = {},\n) {\n  assert(\n    scope || forkPage || safe,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\nconst noopSerializer = (x: any) => x\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  if (scope.warnSerialize) {\n    console.error(\n      'There is a store without sid in this scope, its value is omitted',\n    )\n  }\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    const serializeSettings = scope.sidSerializeSettings.get(sid) ?? {\n      ignore: false,\n      write: noopSerializer,\n    }\n    if (serializeSettings.ignore) return\n    const serializer = serializeSettings.write\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = serializer(scope.reg[id].current)\n    } else {\n      result[sid] = serializer(value)\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n","import {clearNode} from './clearNode'\nimport {createNode} from './createNode'\nimport type {Node, Subscription, Unit} from './index.h'\nimport {step} from './step'\nimport {Scope} from './unit.h'\n\nexport function createWatch<T>({\n  unit,\n  fn,\n  scope,\n}: {\n  unit: Unit<T>\n  fn: (value: T) => any\n  scope?: Scope\n}): Subscription {\n  const seq = [step.run({fn: value => fn(value)})]\n  if (scope) {\n    const node = createNode({node: seq})\n    const id = (unit as any).graphite.id\n    const scopeLinks: {[_: string]: Node[]} = (scope as any).additionalLinks\n    const links = scopeLinks[id] || []\n    scopeLinks[id] = links\n    links.push(node)\n    return createSubscription(() => {\n      const idx = links.indexOf(node)\n      if (idx !== -1) links.splice(idx, 1)\n      clearNode(node)\n    })\n  } else {\n    const node = createNode({\n      node: seq,\n      parent: [unit],\n      family: {owners: unit},\n    })\n    return createSubscription(() => {\n      clearNode(node)\n    })\n  }\n}\n\nfunction createSubscription(callback: () => void): Subscription {\n  const subscription: Subscription = () => callback()\n  subscription.unsubscribe = () => callback()\n\n  return subscription\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","import type {Kind, Unit} from './index.h'\nimport type {Domain, Effect, Event, Scope, Store} from './unit.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {getMeta} from './getter'\n\nexport const unit = (obj: unknown): obj is Unit<any> =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: Kind) => (obj: unknown) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: unknown) => value is Store<unknown>\nexport const event = is(EVENT) as (value: unknown) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: unknown,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: unknown) => value is Domain\nexport const scope = is(SCOPE) as (value: unknown) => value is Scope\nexport const attached = (unit: unknown) =>\n  effect(unit) && getMeta(unit, 'attached') === true\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\nexport const nextEffectID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport type {DataCarrier} from './unit.h'\nimport {getMeta} from './getter'\n\nexport const isObject = (value: unknown): value is Record<any, any> =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: unknown): value is Function =>\n  typeof value === 'function'\n\nexport const isVoid = (value: unknown): value is void => value === undefined\n\nexport const assertObject = (value: unknown) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: unknown,\n  method: string,\n  valueName: string,\n  reason: string,\n): asserts value is DataCarrier =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: unknown,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    //@ts-expect-error some ts assertion edge case\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './index.h'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n  Stack,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = <Type extends 'compute' | 'mov'>(\n  type: Type,\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: {\n    id: string\n    type: Type\n    data: any\n    order?: {\n      priority: BarrierPriorityTag\n      barrierID?: number\n    }\n  } = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data: any, scope: LocalValues, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = <\n  LocalValues extends {[key: string]: any} = {[key: string]: any},\n>(\n  fn: (data: any, scope: LocalValues, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}